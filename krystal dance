--[[
made by sammyc and loadlua
gale fighter by makhail07

i didnt really do much besides fix the player not moving with the clientsided rig
and replacing the other script with gale fighter
with that being said i did not make this - MelonScripter
this script is not owned by me so it is open source
]]

local Motors = {
	["Left Hip"] = 0,
	["Neck"] = 0,
	["Left Shoulder"] = 0,
	["Right Hip"] = 0,
	["Right Shoulder"] = 0
}


local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local RunService = game:GetService("RunService")
game.Players.LocalPlayer.Character.Archivable = true
local FakeCharacter = game.Players.LocalPlayer.Character:Clone()
Player.Character:BreakJoints()
Player.Character=nil
coroutine.wrap(function()

	function LoadLibrary(a)
		local t = {}

		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------JSON Functions Begin----------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------

		--JSON Encoder and Parser for Lua 5.1
		-- 
		--Copyright 2007 Shaun Brown (http://www.chipmunkav.com)
		--All Rights Reserved.

		--Permission is hereby granted, free of charge, to any person
		--obtaining a copy of this software to deal in the Software without
		--restriction, including without limitation the rights to use,
		--copy, modify, merge, publish, distribute, sublicense, and/or
		--sell copies of the Software, and to permit persons to whom the
		--Software is furnished to do so, subject to the following conditions:

		--The above copyright notice and this permission notice shall be
		--included in all copies or substantial portions of the Software.
		--If you find this software useful please give www.chipmunkav.com a mention.

		--THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
		--EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
		--OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
		--IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
		--ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
		--CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
		--CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

		local string = string
		local math = math
		local table = table
		local error = error
		local tonumber = tonumber
		local tostring = tostring
		local type = type
		local setmetatable = setmetatable
		local pairs = pairs
		local ipairs = ipairs
		local assert = assert


		local StringBuilder = {
			buffer = {}
		}

		function StringBuilder:New()
			local o = {}
			setmetatable(o, self)
			self.__index = self
			o.buffer = {}
			return o
		end

		function StringBuilder:Append(s)
			self.buffer[#self.buffer+1] = s
		end

		function StringBuilder:ToString()
			return table.concat(self.buffer)
		end

		local JsonWriter = {
			backslashes = {
				['\b'] = "\\b",
				['\t'] = "\\t",
				['\n'] = "\\n",
				['\f'] = "\\f",
				['\r'] = "\\r",
				['"'] = "\\\"",
				['\\'] = "\\\\",
				['/'] = "\\/"
			}
		}

		function JsonWriter:New()
			local o = {}
			o.writer = StringBuilder:New()
			setmetatable(o, self)
			self.__index = self
			return o
		end

		function JsonWriter:Append(s)
			self.writer:Append(s)
		end

		function JsonWriter:ToString()
			return self.writer:ToString()
		end

		function JsonWriter:Write(o)
			local t = type(o)
			if t == "nil" then
				self:WriteNil()
			elseif t == "boolean" then
				self:WriteString(o)
			elseif t == "number" then
				self:WriteString(o)
			elseif t == "string" then
				self:ParseString(o)
			elseif t == "table" then
				self:WriteTable(o)
			elseif t == "function" then
				self:WriteFunction(o)
			elseif t == "thread" then
				self:WriteError(o)
			elseif t == "userdata" then
				self:WriteError(o)
			end
		end

		function JsonWriter:WriteNil()
			self:Append("null")
		end

		function JsonWriter:WriteString(o)
			self:Append(tostring(o))
		end

		function JsonWriter:ParseString(s)
			self:Append('"')
			self:Append(string.gsub(s, "[%z%c\\\"/]", function(n)
				local c = self.backslashes[n]
				if c then return c end
				return string.format("\\u%.4X", string.byte(n))
			end))
			self:Append('"')
		end

		function JsonWriter:IsArray(t)
			local count = 0
			local isindex = function(k)
				if type(k) == "number" and k > 0 then
					if math.floor(k) == k then
						return true
					end
				end
				return false
			end
			for k,v in pairs(t) do
				if not isindex(k) then
					return false, '{', '}'
				else
					count = math.max(count, k)
				end
			end
			return true, '[', ']', count
		end

		function JsonWriter:WriteTable(t)
			local ba, st, et, n = self:IsArray(t)
			self:Append(st)
			if ba then
				for i = 1, n do
					self:Write(t[i])
					if i < n then
						self:Append(',')
					end
				end
			else
				local first = true;
				for k, v in pairs(t) do
					if not first then
						self:Append(',')
					end
					first = false;
					self:ParseString(k)
					self:Append(':')
					self:Write(v)
				end
			end
			self:Append(et)
		end

		function JsonWriter:WriteError(o)
			error(string.format(
				"Encoding of %s unsupported",
				tostring(o)))
		end

		function JsonWriter:WriteFunction(o)
			if o == Null then
				self:WriteNil()
			else
				self:WriteError(o)
			end
		end

		local StringReader = {
			s = "",
			i = 0
		}

		function StringReader:New(s)
			local o = {}
			setmetatable(o, self)
			self.__index = self
			o.s = s or o.s
			return o
		end

		function StringReader:Peek()
			local i = self.i + 1
			if i <= #self.s then
				return string.sub(self.s, i, i)
			end
			return nil
		end

		function StringReader:Next()
			self.i = self.i+1
			if self.i <= #self.s then
				return string.sub(self.s, self.i, self.i)
			end
			return nil
		end

		function StringReader:All()
			return self.s
		end

		local JsonReader = {
			escapes = {
				['t'] = '\t',
				['n'] = '\n',
				['f'] = '\f',
				['r'] = '\r',
				['b'] = '\b',
			}
		}

		function JsonReader:New(s)
			local o = {}
			o.reader = StringReader:New(s)
			setmetatable(o, self)
			self.__index = self
			return o;
		end

		function JsonReader:Read()
			self:SkipWhiteSpace()
			local peek = self:Peek()
			if peek == nil then
				error(string.format(
					"Nil string: '%s'",
					self:All()))
			elseif peek == '{' then
				return self:ReadObject()
			elseif peek == '[' then
				return self:ReadArray()
			elseif peek == '"' then
				return self:ReadString()
			elseif string.find(peek, "[%+%-%d]") then
				return self:ReadNumber()
			elseif peek == 't' then
				return self:ReadTrue()
			elseif peek == 'f' then
				return self:ReadFalse()
			elseif peek == 'n' then
				return self:ReadNull()
			elseif peek == '/' then
				self:ReadComment()
				return self:Read()
			else
				return nil
			end
		end

		function JsonReader:ReadTrue()
			self:TestReservedWord{'t','r','u','e'}
			return true
		end

		function JsonReader:ReadFalse()
			self:TestReservedWord{'f','a','l','s','e'}
			return false
		end

		function JsonReader:ReadNull()
			self:TestReservedWord{'n','u','l','l'}
			return nil
		end

		function JsonReader:TestReservedWord(t)
			for i, v in ipairs(t) do
				if self:Next() ~= v then
					error(string.format(
						"Error reading '%s': %s",
						table.concat(t),
						self:All()))
				end
			end
		end

		function JsonReader:ReadNumber()
			local result = self:Next()
			local peek = self:Peek()
			while peek ~= nil and string.find(
				peek,
				"[%+%-%d%.eE]") do
				result = result .. self:Next()
				peek = self:Peek()
			end
			result = tonumber(result)
			if result == nil then
				error(string.format(
					"Invalid number: '%s'",
					result))
			else
				return result
			end
		end

		function JsonReader:ReadString()
			local result = ""
			assert(self:Next() == '"')
			while self:Peek() ~= '"' do
				local ch = self:Next()
				if ch == '\\' then
					ch = self:Next()
					if self.escapes[ch] then
						ch = self.escapes[ch]
					end
				end
				result = result .. ch
			end
			assert(self:Next() == '"')
			local fromunicode = function(m)
				return string.char(tonumber(m, 16))
			end
			return string.gsub(
				result,
				"u%x%x(%x%x)",
				fromunicode)
		end

		function JsonReader:ReadComment()
			assert(self:Next() == '/')
			local second = self:Next()
			if second == '/' then
				self:ReadSingleLineComment()
			elseif second == '*' then
				self:ReadBlockComment()
			else
				error(string.format(
					"Invalid comment: %s",
					self:All()))
			end
		end

		function JsonReader:ReadBlockComment()
			local done = false
			while not done do
				local ch = self:Next()
				if ch == '*' and self:Peek() == '/' then
					done = true
				end
				if not done and
					ch == '/' and
					self:Peek() == "*" then
					error(string.format(
						"Invalid comment: %s, '/*' illegal.",
						self:All()))
				end
			end
			self:Next()
		end

		function JsonReader:ReadSingleLineComment()
			local ch = self:Next()
			while ch ~= '\r' and ch ~= '\n' do
				ch = self:Next()
			end
		end

		function JsonReader:ReadArray()
			local result = {}
			assert(self:Next() == '[')
			local done = false
			if self:Peek() == ']' then
				done = true;
			end
			while not done do
				local item = self:Read()
				result[#result+1] = item
				self:SkipWhiteSpace()
				if self:Peek() == ']' then
					done = true
				end
				if not done then
					local ch = self:Next()
					if ch ~= ',' then
						error(string.format(
							"Invalid array: '%s' due to: '%s'",
							self:All(), ch))
					end
				end
			end
			assert(']' == self:Next())
			return result
		end

		function JsonReader:ReadObject()
			local result = {}
			assert(self:Next() == '{')
			local done = false
			if self:Peek() == '}' then
				done = true
			end
			while not done do
				local key = self:Read()
				if type(key) ~= "string" then
					error(string.format(
						"Invalid non-string object key: %s",
						key))
				end
				self:SkipWhiteSpace()
				local ch = self:Next()
				if ch ~= ':' then
					error(string.format(
						"Invalid object: '%s' due to: '%s'",
						self:All(),
						ch))
				end
				self:SkipWhiteSpace()
				local val = self:Read()
				result[key] = val
				self:SkipWhiteSpace()
				if self:Peek() == '}' then
					done = true
				end
				if not done then
					ch = self:Next()
					if ch ~= ',' then
						error(string.format(
							"Invalid array: '%s' near: '%s'",
							self:All(),
							ch))
					end
				end
			end
			assert(self:Next() == "}")
			return result
		end

		function JsonReader:SkipWhiteSpace()
			local p = self:Peek()
			while p ~= nil and string.find(p, "[%s/]") do
				if p == '/' then
					self:ReadComment()
				else
					self:Next()
				end
				p = self:Peek()
			end
		end

		function JsonReader:Peek()
			return self.reader:Peek()
		end

		function JsonReader:Next()
			return self.reader:Next()
		end

		function JsonReader:All()
			return self.reader:All()
		end

		function Encode(o)
			local writer = JsonWriter:New()
			writer:Write(o)
			return writer:ToString()
		end

		function Decode(s)
			local reader = JsonReader:New(s)
			return reader:Read()
		end

		function Null()
			return Null
		end
		-------------------- End JSON Parser ------------------------

		t.DecodeJSON = function(jsonString)
			pcall(function() warn("RbxUtility.DecodeJSON is deprecated, please use Game:GetService('HttpService'):JSONDecode() instead.") end)

			if type(jsonString) == "string" then
				return Decode(jsonString)
			end
			print("RbxUtil.DecodeJSON expects string argument!")
			return nil
		end

		t.EncodeJSON = function(jsonTable)
			pcall(function() warn("RbxUtility.EncodeJSON is deprecated, please use Game:GetService('HttpService'):JSONEncode() instead.") end)
			return Encode(jsonTable)
		end








		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		--------------------------------------------Terrain Utilities Begin-----------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		--makes a wedge at location x, y, z
		--sets cell x, y, z to default material if parameter is provided, if not sets cell x, y, z to be whatever material it previously w
		--returns true if made a wedge, false if the cell remains a block
		t.MakeWedge = function(x, y, z, defaultmaterial)
			return game:GetService("Terrain"):AutoWedgeCell(x,y,z)
		end

		t.SelectTerrainRegion = function(regionToSelect, color, selectEmptyCells, selectionParent)
			local terrain = game:GetService("Workspace"):FindFirstChild("Terrain")
			if not terrain then return end

			assert(regionToSelect)
			assert(color)

			if not type(regionToSelect) == "Region3" then
				error("regionToSelect (first arg), should be of type Region3, but is type",type(regionToSelect))
			end
			if not type(color) == "BrickColor" then
				error("color (second arg), should be of type BrickColor, but is type",type(color))
			end

			-- frequently used terrain calls (speeds up call, no lookup necessary)
			local GetCell = terrain.GetCell
			local WorldToCellPreferSolid = terrain.WorldToCellPreferSolid
			local CellCenterToWorld = terrain.CellCenterToWorld
			local emptyMaterial = Enum.CellMaterial.Empty

			-- container for all adornments, passed back to user
			local selectionContainer = Instance.new("Model")
			selectionContainer.Name = "SelectionContainer"
			selectionContainer.Archivable = false
			if selectionParent then
				selectionContainer.Parent = selectionParent
			else
				selectionContainer.Parent = game:GetService("Workspace")
			end

			local updateSelection = nil -- function we return to allow user to update selection
			local currentKeepAliveTag = nil -- a tag that determines whether adorns should be destroyed
			local aliveCounter = 0 -- helper for currentKeepAliveTag
			local lastRegion = nil -- used to stop updates that do nothing
			local adornments = {} -- contains all adornments
			local reusableAdorns = {}

			local selectionPart = Instance.new("Part")
			selectionPart.Name = "SelectionPart"
			selectionPart.Transparency = 1
			selectionPart.Anchored = true
			selectionPart.Locked = true
			selectionPart.CanCollide = false
			selectionPart.Size = Vector3.new(4.2,4.2,4.2)

			local selectionBox = Instance.new("SelectionBox")

			-- srs translation from region3 to region3int16
			local function Region3ToRegion3int16(region3)
				local theLowVec = region3.CFrame.p - (region3.Size/2) + Vector3.new(2,2,2)
				local lowCell = WorldToCellPreferSolid(terrain,theLowVec)

				local theHighVec = region3.CFrame.p + (region3.Size/2) - Vector3.new(2,2,2)
				local highCell = WorldToCellPreferSolid(terrain, theHighVec)

				local highIntVec = Vector3int16.new(highCell.x,highCell.y,highCell.z)
				local lowIntVec = Vector3int16.new(lowCell.x,lowCell.y,lowCell.z)

				return Region3int16.new(lowIntVec,highIntVec)
			end

			-- helper function that creates the basis for a selection box
			function createAdornment(theColor)
				local selectionPartClone = nil
				local selectionBoxClone = nil

				if #reusableAdorns > 0 then
					selectionPartClone = reusableAdorns[1]["part"]
					selectionBoxClone = reusableAdorns[1]["box"]
					table.remove(reusableAdorns,1)

					selectionBoxClone.Visible = true
				else
					selectionPartClone = selectionPart:Clone()
					selectionPartClone.Archivable = false

					selectionBoxClone = selectionBox:Clone()
					selectionBoxClone.Archivable = false

					selectionBoxClone.Adornee = selectionPartClone
					selectionBoxClone.Parent = selectionContainer

					selectionBoxClone.Adornee = selectionPartClone

					selectionBoxClone.Parent = selectionContainer
				end

				if theColor then
					selectionBoxClone.Color = theColor
				end

				return selectionPartClone, selectionBoxClone
			end

			-- iterates through all current adornments and deletes any that don't have latest tag
			function cleanUpAdornments()
				for cellPos, adornTable in pairs(adornments) do

					if adornTable.KeepAlive ~= currentKeepAliveTag then -- old news, we should get rid of this
						adornTable.SelectionBox.Visible = false
						table.insert(reusableAdorns,{part = adornTable.SelectionPart, box = adornTable.SelectionBox})
						adornments[cellPos] = nil
					end
				end
			end

			-- helper function to update tag
			function incrementAliveCounter()
				aliveCounter = aliveCounter + 1
				if aliveCounter > 1000000 then
					aliveCounter = 0
				end
				return aliveCounter
			end

			-- finds full cells in region and adorns each cell with a box, with the argument color
			function adornFullCellsInRegion(region, color)
				local regionBegin = region.CFrame.p - (region.Size/2) + Vector3.new(2,2,2)
				local regionEnd = region.CFrame.p + (region.Size/2) - Vector3.new(2,2,2)

				local cellPosBegin = WorldToCellPreferSolid(terrain, regionBegin)
				local cellPosEnd = WorldToCellPreferSolid(terrain, regionEnd)

				currentKeepAliveTag = incrementAliveCounter()
				for y = cellPosBegin.y, cellPosEnd.y do
					for z = cellPosBegin.z, cellPosEnd.z do
						for x = cellPosBegin.x, cellPosEnd.x do
							local cellMaterial = GetCell(terrain, x, y, z)

							if cellMaterial ~= emptyMaterial then
								local cframePos = CellCenterToWorld(terrain, x, y, z)
								local cellPos = Vector3int16.new(x,y,z)

								local updated = false
								for cellPosAdorn, adornTable in pairs(adornments) do
									if cellPosAdorn == cellPos then
										adornTable.KeepAlive = currentKeepAliveTag
										if color then
											adornTable.SelectionBox.Color = color
										end
										updated = true
										break
									end
								end

								if not updated then
									local selectionPart, selectionBox = createAdornment(color)
									selectionPart.Size = Vector3.new(4,4,4)
									selectionPart.CFrame = CFrame.new(cframePos)
									local adornTable = {SelectionPart = selectionPart, SelectionBox = selectionBox, KeepAlive = currentKeepAliveTag}
									adornments[cellPos] = adornTable
								end
							end
						end
					end
				end
				cleanUpAdornments()
			end


			------------------------------------- setup code ------------------------------
			lastRegion = regionToSelect

			if selectEmptyCells then -- use one big selection to represent the area selected
				local selectionPart, selectionBox = createAdornment(color)

				selectionPart.Size = regionToSelect.Size
				selectionPart.CFrame = regionToSelect.CFrame

				adornments.SelectionPart = selectionPart
				adornments.SelectionBox = selectionBox

				updateSelection =
					function (newRegion, color)
						if newRegion and newRegion ~= lastRegion then
						lastRegion = newRegion
						selectionPart.Size = newRegion.Size
						selectionPart.CFrame = newRegion.CFrame
					end
						if color then
						selectionBox.Color = color
					end
					end
			else -- use individual cell adorns to represent the area selected
				adornFullCellsInRegion(regionToSelect, color)
				updateSelection =
					function (newRegion, color)
						if newRegion and newRegion ~= lastRegion then
						lastRegion = newRegion
						adornFullCellsInRegion(newRegion, color)
					end
					end

			end

			local destroyFunc = function()
				updateSelection = nil
				if selectionContainer then selectionContainer:Destroy() end
				adornments = nil
			end

			return updateSelection, destroyFunc
		end

		-----------------------------Terrain Utilities End-----------------------------







		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------Signal class begin------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
--[[
A 'Signal' object identical to the internal RBXScriptSignal object in it's public API and semantics. This function
can be used to create "custom events" for user-made code.
API:
Method :connect( function handler )
Arguments: The function to connect to.
Returns: A new connection object which can be used to disconnect the connection
Description: Connects this signal to the function specified by |handler|. That is, when |fire( ... )| is called for
the signal the |handler| will be called with the arguments given to |fire( ... )|. Note, the functions
connected to a signal are called in NO PARTICULAR ORDER, so connecting one function after another does
NOT mean that the first will be called before the second as a result of a call to |fire|.
 
Method :disconnect()
Arguments: None
Returns: None
Description: Disconnects all of the functions connected to this signal.
 
Method :fire( ... )
Arguments: Any arguments are accepted
Returns: None
Description: Calls all of the currently connected functions with the given arguments.
 
Method :wait()
Arguments: None
Returns: The arguments given to fire
Description: This call blocks until
]]

		function t.CreateSignal()
			local this = {}

			local mBindableEvent = Instance.new('BindableEvent')
			local mAllCns = {} --all connection objects returned by mBindableEvent::connect

			--main functions
			function this:connect(func)
				if self ~= this then error("connect must be called with `:`, not `.`", 2) end
				if type(func) ~= 'function' then
					error("Argument #1 of connect must be a function, got a "..type(func), 2)
				end
				local cn = mBindableEvent.Event:Connect(func)
				mAllCns[cn] = true
				local pubCn = {}
				function pubCn:disconnect()
					cn:Disconnect()
					mAllCns[cn] = nil
				end
				pubCn.Disconnect = pubCn.disconnect

				return pubCn
			end

			function this:disconnect()
				if self ~= this then error("disconnect must be called with `:`, not `.`", 2) end
				for cn, _ in pairs(mAllCns) do
					cn:Disconnect()
					mAllCns[cn] = nil
				end
			end

			function this:wait()
				if self ~= this then error("wait must be called with `:`, not `.`", 2) end
				return mBindableEvent.Event:Wait()
			end

			function this:fire(...)
				if self ~= this then error("fire must be called with `:`, not `.`", 2) end
				mBindableEvent:Fire(...)
			end

			this.Connect = this.connect
			this.Disconnect = this.disconnect
			this.Wait = this.wait
			this.Fire = this.fire

			return this
		end

		------------------------------------------------- Sigal class End ------------------------------------------------------




		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		-----------------------------------------------Create Function Begins---------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
--[[
A "Create" function for easy creation of Roblox instances. The function accepts a string which is the classname of
the object to be created. The function then returns another function which either accepts accepts no arguments, in
which case it simply creates an object of the given type, or a table argument that may contain several types of data,
in which case it mutates the object in varying ways depending on the nature of the aggregate data. These are the
type of data and what operation each will perform:
1) A string key mapping to some value:
Key-Value pairs in this form will be treated as properties of the object, and will be assigned in NO PARTICULAR
ORDER. If the order in which properties is assigned matter, then they must be assigned somewhere else than the
|Create| call's body.
 
2) An integral key mapping to another Instance:
Normal numeric keys mapping to Instances will be treated as children if the object being created, and will be
parented to it. This allows nice recursive calls to Create to create a whole hierarchy of objects without a
need for temporary variables to store references to those objects.
 
3) A key which is a value returned from Create.Event( eventname ), and a value which is a function function
The Create.E( string ) function provides a limited way to connect to signals inside of a Create hierarchy
for those who really want such a functionality. The name of the event whose name is passed to
Create.E( string )
 
4) A key which is the Create function itself, and a value which is a function
The function will be run with the argument of the object itself after all other initialization of the object is
done by create. This provides a way to do arbitrary things involving the object from withing the create
hierarchy.
Note: This function is called SYNCHRONOUSLY, that means that you should only so initialization in
it, not stuff which requires waiting, as the Create call will block until it returns. While waiting in the
constructor callback function is possible, it is probably not a good design choice.
Note: Since the constructor function is called after all other initialization, a Create block cannot have two
constructor functions, as it would not be possible to call both of them last, also, this would be unnecessary.
 
 
Some example usages:
 
A simple example which uses the Create function to create a model object and assign two of it's properties.
local model = Create'Model'{
Name = 'A New model',
Parent = game.Workspace,
}
 
 
An example where a larger hierarchy of object is made. After the call the hierarchy will look like this:
Model_Container
|-ObjectValue
| |
| `-BoolValueChild
`-IntValue
 
local model = Create'Model'{
Name = 'Model_Container',
Create'ObjectValue'{
Create'BoolValue'{
Name = 'BoolValueChild',
},
},
Create'IntValue'{},
}
 
 
An example using the event syntax:
 
local part = Create'Part'{
[Create.E'Touched'] = function(part)
print("I was touched by "..part.Name)
end,
}
 
 
An example using the general constructor syntax:
 
local model = Create'Part'{
[Create] = function(this)
print("Constructor running!")
this.Name = GetGlobalFoosAndBars(this)
end,
}
 
 
Note: It is also perfectly legal to save a reference to the function returned by a call Create, this will not cause
any unexpected behavior. EG:
local partCreatingFunction = Create'Part'
local part = partCreatingFunction()
]]

		--the Create function need to be created as a functor, not a function, in order to support the Create.E syntax, so it
		--will be created in several steps rather than as a single function declaration.
		local function Create_PrivImpl(objectType)
			if type(objectType) ~= 'string' then
				error("Argument of Create must be a string", 2)
			end
			--return the proxy function that gives us the nice Create'string'{data} syntax
			--The first function call is a function call using Lua's single-string-argument syntax
			--The second function call is using Lua's single-table-argument syntax
			--Both can be chained together for the nice effect.
			return function(dat)
				--default to nothing, to handle the no argument given case
				dat = dat or {}

				--make the object to mutate
				local obj = Instance.new(objectType)
				local parent = nil

				--stored constructor function to be called after other initialization
				local ctor = nil

				for k, v in pairs(dat) do
					--add property
					if type(k) == 'string' then
						if k == 'Parent' then
							-- Parent should always be set last, setting the Parent of a new object
							-- immediately makes performance worse for all subsequent property updates.
							parent = v
						else
							obj[k] = v
						end


						--add child
					elseif type(k) == 'number' then
						if type(v) ~= 'userdata' then
							error("Bad entry in Create body: Numeric keys must be paired with children, got a: "..type(v), 2)
						end
						v.Parent = obj


						--event connect
					elseif type(k) == 'table' and k.__eventname then
						if type(v) ~= 'function' then
							error("Bad entry in Create body: Key `[Create.E\'"..k.__eventname.."\']` must have a function value\
got: "..tostring(v), 2)
						end
						obj[k.__eventname]:connect(v)


						--define constructor function
					elseif k == t.Create then
						if type(v) ~= 'function' then
							error("Bad entry in Create body: Key `[Create]` should be paired with a constructor function, \
got: "..tostring(v), 2)
						elseif ctor then
							--ctor already exists, only one allowed
							error("Bad entry in Create body: Only one constructor function is allowed", 2)
						end
						ctor = v


					else
						error("Bad entry ("..tostring(k).." => "..tostring(v)..") in Create body", 2)
					end
				end

				--apply constructor function if it exists
				if ctor then
					ctor(obj)
				end

				if parent then
					obj.Parent = parent
				end

				--return the completed object
				return obj
			end
		end

		--now, create the functor:
		t.Create = setmetatable({}, {__call = function(tb, ...) return Create_PrivImpl(...) end})

		--and create the "Event.E" syntax stub. Really it's just a stub to construct a table which our Create
		--function can recognize as special.
		t.Create.E = function(eventName)
			return {__eventname = eventName}
		end

		-------------------------------------------------Create function End----------------------------------------------------




		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------Documentation Begin-----------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------

		t.Help =
			function(funcNameOrFunc)
				--input argument can be a string or a function. Should return a description (of arguments and expected side effects)
				if funcNameOrFunc == "DecodeJSON" or funcNameOrFunc == t.DecodeJSON then
				return "Function DecodeJSON. " ..
					"Arguments: (string). " ..
					"Side effect: returns a table with all parsed JSON values"
			end
				if funcNameOrFunc == "EncodeJSON" or funcNameOrFunc == t.EncodeJSON then
				return "Function EncodeJSON. " ..
					"Arguments: (table). " ..
					"Side effect: returns a string composed of argument table in JSON data format"
			end
				if funcNameOrFunc == "MakeWedge" or funcNameOrFunc == t.MakeWedge then
				return "Function MakeWedge. " ..
					"Arguments: (x, y, z, [default material]). " ..
					"Description: Makes a wedge at location x, y, z. Sets cell x, y, z to default material if "..
					"parameter is provided, if not sets cell x, y, z to be whatever material it previously was. "..
					"Returns true if made a wedge, false if the cell remains a block "
			end
				if funcNameOrFunc == "SelectTerrainRegion" or funcNameOrFunc == t.SelectTerrainRegion then
				return "Function SelectTerrainRegion. " ..
					"Arguments: (regionToSelect, color, selectEmptyCells, selectionParent). " ..
					"Description: Selects all terrain via a series of selection boxes within the regionToSelect " ..
					"(this should be a region3 value). The selection box color is detemined by the color argument " ..
					"(should be a brickcolor value). SelectionParent is the parent that the selection model gets placed to (optional)." ..
					"SelectEmptyCells is bool, when true will select all cells in the " ..
					"region, otherwise we only select non-empty cells. Returns a function that can update the selection," ..
					"arguments to said function are a new region3 to select, and the adornment color (color arg is optional). " ..
					"Also returns a second function that takes no arguments and destroys the selection"
			end
				if funcNameOrFunc == "CreateSignal" or funcNameOrFunc == t.CreateSignal then
				return "Function CreateSignal. "..
					"Arguments: None. "..
					"Returns: The newly created Signal object. This object is identical to the RBXScriptSignal class "..
					"used for events in Objects, but is a Lua-side object so it can be used to create custom events in"..
					"Lua code. "..
					"Methods of the Signal object: :connect, :wait, :fire, :disconnect. "..
					"For more info you can pass the method name to the Help function, or view the wiki page "..
					"for this library. EG: Help('Signal:connect')."
			end
				if funcNameOrFunc == "Signal:connect" then
				return "Method Signal:connect. "..
					"Arguments: (function handler). "..
					"Return: A connection object which can be used to disconnect the connection to this handler. "..
					"Description: Connectes a handler function to this Signal, so that when |fire| is called the "..
					"handler function will be called with the arguments passed to |fire|."
			end
				if funcNameOrFunc == "Signal:wait" then
				return "Method Signal:wait. "..
					"Arguments: None. "..
					"Returns: The arguments passed to the next call to |fire|. "..
					"Description: This call does not return until the next call to |fire| is made, at which point it "..
					"will return the values which were passed as arguments to that |fire| call."
			end
				if funcNameOrFunc == "Signal:fire" then
				return "Method Signal:fire. "..
					"Arguments: Any number of arguments of any type. "..
					"Returns: None. "..
					"Description: This call will invoke any connected handler functions, and notify any waiting code "..
					"attached to this Signal to continue, with the arguments passed to this function. Note: The calls "..
					"to handlers are made asynchronously, so this call will return immediately regardless of how long "..
					"it takes the connected handler functions to complete."
			end
				if funcNameOrFunc == "Signal:disconnect" then
				return "Method Signal:disconnect. "..
					"Arguments: None. "..
					"Returns: None. "..
					"Description: This call disconnects all handlers attacched to this function, note however, it "..
					"does NOT make waiting code continue, as is the behavior of normal Roblox events. This method "..
					"can also be called on the connection object which is returned from Signal:connect to only "..
					"disconnect a single handler, as opposed to this method, which will disconnect all handlers."
			end
				if funcNameOrFunc == "Create" then
				return "Function Create. "..
					"Arguments: A table containing information about how to construct a collection of objects. "..
					"Returns: The constructed objects. "..
					"Descrition: Create is a very powerfull function, whose description is too long to fit here, and "..
					"is best described via example, please see the wiki page for a description of how to use it."
			end
			end

		--------------------------------------------Documentation Ends----------------------------------------------------------

		return t
	end
	
	-----------//KRYSTAL DANCE V2\\-----------
--[[Movelist
Q = The Swoosher
E = The nutty
R = Spin me right round!
T = Plum juice dance
Y = Moonwalk
U = Slav dance
P = Barrel roll
F = The Jerky
G = The Shuffle
H = The Spongebob
J = Here comes the money!
K = Runnin' in the 90's
---------]]

	--Alright so before i start rambling on about absolute nonsense, please subscribe to Pewdiepie on youtube! Help him defeat T-Series!--
	--Also do not subscribe to VengefulPedo he's a fucking faggot who grooms minors lmfao--
	--Krystal dance! The old famous script that sadly has been broken(sorta), i've decided to rework this thing because... nostalgia.--
	--This is one of the first scripts i've ever ran on SB, seeing this back again really reminds me of how much of a noob i was.--
	--Credits to Krystalteam, they made the original krystal dance! Be sure to respect them or else...--
	--#makeoldscriptsgreatagain--

	Player=game.Players.LocalPlayer
	Character=FakeCharacter
	Character.Humanoid.Name = "noneofurbusiness"
	hum = Character.noneofurbusiness
	LeftArm=Character["Left Arm"]
	LeftLeg=Character["Left Leg"]
	RightArm=Character["Right Arm"]
	RightLeg=Character["Right Leg"]
	Root=Character["HumanoidRootPart"]
	Head=Character["Head"]
	Torso=Character["Torso"]
	Neck=Torso["Neck"]
	mouse = Player:GetMouse()
	walking = false
	jumping = false
	attacking = false
	firsttime = false
	tauntdebounce = false
	position = nil
	MseGuide = true
	running = false
	settime = 0
	sine = 0
	t = 0
	ws = 14
	change = 1
	combo1 = true
	dancing = false
	equip = false
	dgs = 75
	combo2 = false
	switch1 = true
	switch2 = false
	firsttime2 = false
	combo3 = false
	gunallowance = false
	shooting = false
	RunSrv = game:GetService("RunService")
	RenderStepped = game:GetService("RunService").RenderStepped
	removeuseless = game:GetService("Debris")

	screenGui = Instance.new("ScreenGui")
	screenGui.Parent = script.Parent

	local HEADLERP = Instance.new("ManualWeld")
	HEADLERP.Parent = Head
	HEADLERP.Part0 = Head
	HEADLERP.Part1 = Head
	HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local TORSOLERP = Instance.new("ManualWeld")
	TORSOLERP.Parent = Root
	TORSOLERP.Part0 = Torso
	TORSOLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local ROOTLERP = Instance.new("ManualWeld")
	ROOTLERP.Parent = Root
	ROOTLERP.Part0 = Root
	ROOTLERP.Part1 = Torso
	ROOTLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local RIGHTARMLERP = Instance.new("ManualWeld")
	RIGHTARMLERP.Parent = RightArm
	RIGHTARMLERP.Part0 = RightArm
	RIGHTARMLERP.Part1 = Torso
	RIGHTARMLERP.C0 = CFrame.new(-1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local LEFTARMLERP = Instance.new("ManualWeld")
	LEFTARMLERP.Parent = LeftArm
	LEFTARMLERP.Part0 = LeftArm
	LEFTARMLERP.Part1 = Torso
	LEFTARMLERP.C0 = CFrame.new(1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local RIGHTLEGLERP = Instance.new("ManualWeld")
	RIGHTLEGLERP.Parent = RightLeg
	RIGHTLEGLERP.Part0 = RightLeg
	RIGHTLEGLERP.Part1 = Torso
	RIGHTLEGLERP.C0 = CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local LEFTLEGLERP = Instance.new("ManualWeld")
	LEFTLEGLERP.Parent = LeftLeg
	LEFTLEGLERP.Part0 = LeftLeg
	LEFTLEGLERP.Part1 = Torso
	LEFTLEGLERP.C0 = CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

	local function weldBetween(a, b)
		local weld = Instance.new("ManualWeld", a)
		weld.Part0 = a
		weld.Part1 = b
		weld.C0 = a.CFrame:inverse() * b.CFrame
		return weld
	end

	function MAKETRAIL(PARENT,POSITION1,POSITION2,LIFETIME,COLOR)
		A = Instance.new("Attachment", PARENT)
		A.Position = POSITION1
		A.Name = "A"
		B = Instance.new("Attachment", PARENT)
		B.Position = POSITION2
		B.Name = "B"
		tr1 = Instance.new("Trail", PARENT)
		tr1.Attachment0 = A
		tr1.Attachment1 = B
		tr1.Enabled = true
		tr1.Lifetime = LIFETIME
		tr1.TextureMode = "Static"
		tr1.LightInfluence = 0
		tr1.Color = COLOR
		tr1.Transparency = NumberSequence.new(0, 1)
	end

	introsound = Instance.new("Sound",Head)
	introsound.SoundId = "rbxassetid://236146895"
	introsound.Volume = 8
	introsound:Play()


	fedora = Instance.new("Part",Character)
	fedora.Size = Vector3.new(2,2,2)
	fedora.CFrame = Head.CFrame
	fedora.CanCollide = false
	fedoraweld = Instance.new("Weld",fedora)
	fedoraweld.Part0 = fedora
	fedoraweld.Part1 = Head
	fedoraweld.C0 = fedora.CFrame:inverse() * Head.CFrame * CFrame.new(0,-.75,0)
	mfedora = Instance.new("SpecialMesh", fedora)
	mfedora.MeshType = "FileMesh"
	mfedora.Scale = Vector3.new(.97, .97, .97)
	mfedora.MeshId,mfedora.TextureId = 'http://www.roblox.com/asset/?id=13640868','http://www.roblox.com/asset/?id=18987684'

	shades = Instance.new("Part",Character)
	shades.Size = Vector3.new(2,2,2)
	shades.CFrame = Head.CFrame
	shades.CanCollide = false
	shadesweld = Instance.new("Weld",shades)
	shadesweld.Part0 = shades
	shadesweld.Part1 = Head
	shadesweld.C0 = shades.CFrame:inverse() * Head.CFrame * CFrame.new(0,-.2,.15)
	mshades = Instance.new("SpecialMesh", shades)
	mshades.MeshType = "FileMesh"
	mshades.Scale = Vector3.new(1.04, 1.28, 1.04)
	mshades.MeshId,mshades.TextureId = 'http://www.roblox.com/asset/?id=1577360','http://www.roblox.com/asset/?id=1577349'

	godmode = coroutine.wrap(function()
		for i,v in pairs(Character:GetChildren()) do
			if v:IsA("BasePart") and v ~= Root then
				v.Anchored = false
			end
		end
		while true do
			hum.MaxHealth = math.huge
			wait(0.0000001)
			hum.Health = math.huge
			wait()
		end
	end)
	godmode()
	ff = Instance.new("ForceField", Character)
	ff.Visible = false

	coroutine.wrap(function()
		for i,v in pairs(Character:GetChildren()) do
			if v.Name == "Animate" then v:Remove()
			end
		end
	end)()

	function damagealll(Radius,Position)		
		local Returning = {}		
		for _,v in pairs(workspace:GetChildren()) do		
			if v~=Character and v:FindFirstChildOfClass('Humanoid') and v:FindFirstChild('Torso') or v:FindFirstChild('UpperTorso') then
				if v:FindFirstChild("Torso") then		
					local Mag = (v.Torso.Position - Position).magnitude		
					if Mag < Radius then		
						table.insert(Returning,v)		
					end
				elseif v:FindFirstChild("UpperTorso") then	
					local Mag = (v.UpperTorso.Position - Position).magnitude		
					if Mag < Radius then		
						table.insert(Returning,v)		
					end
				end	
			end		
		end		
		return Returning		
	end

	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "Heartbeat"
	script:WaitForChild("Heartbeat")

	frame = 1 / 60
	tf = 0
	allowframeloss = false
	tossremainder = false


	lastframe = tick()
	script.Heartbeat:Fire()


	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.Heartbeat:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.Heartbeat:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	function swait(num)
		if num == 0 or num == nil then
			game:service("RunService").Stepped:wait(0)
		else
			for i = 0, num do
				game:service("RunService").Stepped:wait(0)
			end
		end
	end

	for _,n in pairs(Character:GetChildren()) do
		if n:IsA("Accessory") then n:Remove() end
	end
	for _,x in pairs(Character:GetChildren()) do
		if x:IsA("Decal") then x:Remove() end
	end

	intro = true
	ws = 0

	bigfedora = Instance.new("Part",Character)
	bigfedora.Size = Vector3.new(2,2,2)
	bigfedora.CFrame = bigfedora.CFrame:inverse() * Root.CFrame * CFrame.new(math.random(-60,60),-.2,math.random(-60,60)) * CFrame.Angles(0,math.rad(math.random(-180,180)),0)
	bigfedora.CanCollide = false
	bigfedora.Anchored = true
	bigfedora.Name = "mbigf"
	mbigfedora = Instance.new("SpecialMesh", bigfedora)
	mbigfedora.MeshType = "FileMesh"
	mbigfedora.Scale = Vector3.new(6, 7, 7)
	mbigfedora.MeshId,mbigfedora.TextureId = 'http://www.roblox.com/asset/?id=13640868','http://www.roblox.com/asset/?id=18987684'
	for i,v in pairs(Character:GetDescendants()) do
		if v:IsA("Part") and v.Name ~= "mbigf" then v.Transparency = 1
		end
	end
	for i = 1, 60 do
		bigfedora.CFrame = bigfedora.CFrame:lerp(CFrame.new(Root.Position) * CFrame.new(0,-.1,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.09)
		swait()
	end
	wait(.25)
	for i,v in pairs(Character:GetDescendants()) do
		if v:IsA("Part") and v.Name ~= "mbigf" and v.Name ~= "HumanoidRootPart" then v.Transparency = 0
		end
	end
	for i = 1, 50 do
		bigfedora.CFrame = bigfedora.CFrame:lerp(CFrame.new(fedora.Position),.05)
		swait()
	end
	zmc = 0
	for i = 1, 29 do
		zmc = zmc + 2
		mbigfedora.Scale = mbigfedora.Scale - Vector3.new(.25,.25,.25)
		bigfedora.CFrame = bigfedora.CFrame * CFrame.Angles(math.rad(0),math.rad(zmc),0)
		swait()
	end
	bigfedora:Remove()

	ws = 14

	function SOUND(PARENT,ID,VOL,LOOP,REMOVE)
		so = Instance.new("Sound")
		so.Parent = PARENT
		so.SoundId = "rbxassetid://"..ID
		so.Volume = VOL
		so.Looped = LOOP

		so:Play()
		removeuseless:AddItem(so,REMOVE)
	end

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='k' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				attacking = true
				jam = Instance.new("Sound",Torso)
				jam.SoundId = "rbxassetid://665751753"
				jam.Volume = 8
				jam.Looped = true
				jam.TimePosition = 22.3
				jam:Play()
				lol90 = 0
				coroutine.wrap(function()
					while dancing do
						lol90 = lol90 + 11
						ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(1 * math.sin(sine/10),.1 + .8 * math.sin(sine/3),0) * CFrame.Angles(math.rad(0),math.rad(0 * math.sin(sine/8)),math.rad(8 * math.sin(sine/7))),.25)
						ROOTLERP.C1 = ROOTLERP.C1:lerp(CFrame.new(0 * math.sin(sine/14),0,0) * CFrame.Angles(math.rad(0),math.rad(lol90),0),.25)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(-5 * math.sin(sine/3)),math.rad(-6 * math.sin(sine/3))),0.25)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(5 * math.sin(sine/3)),math.rad(6 * math.sin(sine/3))), 0.25)
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , 0) * CFrame.Angles(0, math.rad(0), math.rad(-10 + 5 * math.sin(sine/3))), 0.25)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10 - 5 * math.sin(sine/3))), 0.25)
						swait()
					end
					ws = 14
					jam:Remove()
					ROOTLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='j' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 3
				change = .5
				attacking = true
				g1 = Instance.new("BodyGyro", Root)
				g1.D = 175
				g1.P = 20000
				g1.MaxTorque = Vector3.new(0,9000,0)
				herecomesthemoney = Instance.new("Sound",Torso)
				herecomesthemoney.Pitch = 1
				herecomesthemoney.SoundId = "rbxassetid://2426693638"
				herecomesthemoney.Volume = 8
				herecomesthemoney.Looped = true
				herecomesthemoney:Play()
				robuxpile = Instance.new("Part",Torso)
				robuxpile.Size = Vector3.new(1,1,1)
				robuxpile.CFrame = LeftArm.CFrame
				robuxpile.CanCollide = false
				robuxpileweld = Instance.new("Weld",robuxpile)
				robuxpileweld.Part0 = robuxpile
				robuxpileweld.Part1 = Torso
				robuxpileweld.C0 = robuxpile.CFrame:inverse() * LeftArm.CFrame * CFrame.new(1,-.7,1.4)
				mrobuxpile = Instance.new("SpecialMesh", robuxpile)
				mrobuxpile.MeshType = "FileMesh"
				mrobuxpile.Scale = Vector3.new(0.85, .85, .85)
				mrobuxpile.MeshId,mrobuxpile.TextureId = 'http://www.roblox.com/asset/?id=1285245','http://www.roblox.com/asset/?id=8587344'
				coroutine.wrap(function()
					coroutine.wrap(function()
						while wait(.35) do
							if not dancing then break end
							local robux = Instance.new("Part",Torso)
							robux.CFrame = robuxpile.CFrame * CFrame.Angles(math.rad(0),math.rad(90),math.rad(90))
							robux.Anchored = false
							robux.CanCollide = true
							robux.Size = Vector3.new(1,1,1)
							removeuseless:AddItem(robux,4)
							mrobux = Instance.new("SpecialMesh", robux)
							mrobux.MeshType = "FileMesh"
							mrobux.Scale = Vector3.new(1.25, 1.25, 1.25)
							mrobux.MeshId,mrobux.TextureId = 'http://www.roblox.com/asset/?id=667285348','http://www.roblox.com/asset/?id=665939136'
							bov = Instance.new("BodyVelocity",robux)
							bov.maxForce = Vector3.new(99999,99999,99999)
							robux.CFrame = CFrame.new(robux.Position,mouse.Hit.p)
							bov.velocity = robux.CFrame.lookVector*45
							removeuseless:AddItem(bov,.1)
						end
					end)()
					while dancing do
						g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
						ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.3,0) * CFrame.Angles(math.rad(20),math.rad(0 * math.sin(sine/8)),math.rad(0)),.25)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,.5 + .5 * math.sin(sine/2),.5) * CFrame.Angles(math.rad(-97),math.rad(40 - 20 * math.sin(sine/2)),math.rad(0)), 0.25)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1,.5,.5) * CFrame.Angles(math.rad(-87),math.rad(-20),math.rad(0)), 0.25)
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , .5) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(-10)), 0.25)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, .5) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(10)), 0.25)
						swait()
					end
					ws = 14
					removeuseless:AddItem(g1,.001)
					robuxpile:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='h' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				attacking = true
				jellyfishjam = Instance.new("Sound",Torso)
				jellyfishjam.SoundId = "rbxassetid://840189092"
				jellyfishjam.Volume = 8
				jellyfishjam.Looped = true
				jellyfishjam.TimePosition = 14.8
				jellyfishjam:Play()
				coroutine.wrap(function()
					while dancing do
						for i = 1, 15 do
							if not dancing then break end
							ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(.5,-.4 + .1 * math.sin(sine/4),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(20)),.25)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(0.25, 2.05,-0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-35)), 0.25)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2.05,-0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(14)), 0.25)
							swait()
						end
						for i = 1, 15 do
							if not dancing then break end
							ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.1 * math.sin(sine/4),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(0)),.25)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.25, .7,1.5) * CFrame.Angles(math.rad(72), math.rad(25), math.rad(-2)), 0.25)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10)), 0.25)
							swait()
						end
						for i = 1, 15 do
							if not dancing then break end
							ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(-.5,-.4 + .1 * math.sin(sine/4),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(-20)),.25)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , 0) * CFrame.Angles(0, math.rad(0), math.rad(-10)), 0.25)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(-0.25, 2.05,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(35)), 0.25)
							swait()
						end
						for i = 1, 15 do
							if not dancing then break end
							ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(-.5,-.1,0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(0)),.25)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2.05,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-14)), 0.3)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.25, .7,1.5) * CFrame.Angles(math.rad(72), math.rad(-25), math.rad(-2)), 0.25)
							swait()
						end
						swait()
					end
					ws = 14
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='g' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				attacking = true
				deadmau7 = Instance.new("Sound",Torso)
				deadmau7.SoundId = "rbxassetid://168166611"
				deadmau7.Volume = 8
				deadmau7.Looped = true
				deadmau7:Play()
				coroutine.wrap(function()
					coroutine.wrap(function()
						while dancing do
							ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(2 * math.sin(sine/9),-.4 + .1 * math.sin(sine/3),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/9)),0),.25)
							swait()
						end
					end)()
					while dancing do
						for i = 1, 28 do
							if not dancing then break end
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.2)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.2,1.5,0) * CFrame.Angles(math.rad(180 - 7 * math.sin(sine/3)),math.rad(7 * math.sin(sine/3)),math.rad(7*math.sin(sine/3))), 0.2)
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, .7,1) * CFrame.Angles(math.rad(75 - 10 * math.sin(sine/2)), math.rad(0), math.rad(0)), 0.25)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2.05,-.1) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(-2)), 0.3)
							swait()
						end
						for i = 1, 28 do
							if not dancing then break end
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.2)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.2,1.5,0) * CFrame.Angles(math.rad(180 - 7 * math.sin(sine/3)),math.rad(7 * math.sin(sine/3)),math.rad(7*math.sin(sine/3))), 0.2)
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2.05,.1) * CFrame.Angles(math.rad(-10), math.rad(0), math.rad(-8)), 0.25)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, .7,1.1) * CFrame.Angles(math.rad(75 - 10 * math.sin(sine/2)), math.rad(0), math.rad(-2)), 0.25)
							swait()
						end
						swait()
					end
					ws = 14
					deadmau7:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='f' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 6
				change = .5
				attacking = true
				bennyhill = Instance.new("Sound",Torso)
				bennyhill.SoundId = "rbxassetid://138211362"
				bennyhill.Volume = 8
				bennyhill.Looped = true
				bennyhill:Play()
				coroutine.wrap(function()
					while dancing do
						ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.4,0) * CFrame.Angles(math.rad(20 + 5 * math.sin(sine/2)),math.rad(10 * math.sin(sine/4)),0),.25)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.89 - .4 * -math.sin(sine/2),.49) * CFrame.Angles(math.rad(-70 + 20 * -math.sin(sine/2)),0,math.rad(0)),.25)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.89 - .4 * math.sin(sine/2),.49) * CFrame.Angles(math.rad(-70  + 20 * math.sin(sine/2)),0,math.rad(0)),.25)
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.33, 2, -.2 + .3 * math.sin(sine/2)) * CFrame.Angles(math.rad(-20 - 20 * -math.sin(sine/2)), math.rad(0), math.rad(-8)), 0.25)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.33, 2.0,-.2 - .3 * math.sin(sine/2)) * CFrame.Angles(math.rad(-20 - 20 * math.sin(sine/2)), math.rad(0), math.rad(8)), 0.25)
						swait()
					end
					ws = 14
					bennyhill:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='p' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				attacking = true
				barrelspin = 0
				barrelrollsound = Instance.new("Sound",Torso)
				barrelrollsound.SoundId = "rbxassetid://505320170"
				barrelrollsound.Volume = 8
				barrelrollsound.Looped = true
				barrelrollsound:Play()
				barrol = Instance.new("Part",Torso)
				barrol.Size = Vector3.new(1,1,1)
				barrol.CFrame = Torso.CFrame
				barrol.CanCollide = false
				barrolweld = Instance.new("Weld",barrol)
				barrolweld.Part0 = barrol
				barrolweld.Part1 = Torso
				barrolweld.C0 = barrol.CFrame:inverse() * Torso.CFrame * CFrame.new(0,0,0)
				mbarrol = Instance.new("SpecialMesh", barrol)
				mbarrol.MeshType = "FileMesh"
				mbarrol.Scale = Vector3.new(1.05, .95, 1.05)
				mbarrol.MeshId,mbarrol.TextureId = 'http://www.roblox.com/asset/?id=29873142','http://www.roblox.com/asset/?id=31082268'
				coroutine.wrap(function()
					while dancing do
						ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(5 * math.sin(sine/8),-1.8,0) * CFrame.Angles(math.rad(-90),math.rad(180 * math.sin(sine/8)),0),.25)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,1.5,0) * CFrame.Angles(math.rad(180),0,math.rad(0)),.25)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,1.5,0) * CFrame.Angles(math.rad(180),0,math.rad(0)),.25)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(.5,2,0) * CFrame.Angles(0,0,0),.25)
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-.5,2,0) * CFrame.Angles(0,0,0),.25)
						swait()
					end
					ws = 14
					barrol:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='q' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				spinningmove = 0
				dbwouldlovethis = Instance.new("Sound",Torso)
				dbwouldlovethis.SoundId = "rbxassetid://1532157598"
				dbwouldlovethis.Volume = 8
				dbwouldlovethis.Looped = true
				dbwouldlovethis:Play()
				attacking = true
				coroutine.wrap(function()
					while dancing do
						spinningmove = spinningmove + 10
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.52, 1.9, -.35) * CFrame.Angles(math.rad(-30), math.rad(0), math.rad(0)),.2)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.52, 1.9, .35) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)),.2)
						ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(.2 * math.sin(sine/3), -.52, .2 * math.sin(sine/4)) * CFrame.Angles(math.rad(180),math.rad(spinningmove),math.rad(15 * math.sin(sine/9))),.2)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(-1),math.rad(-3 * math.sin(sine/2))),0.3)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(1),math.rad(3 * math.sin(sine/2))), 0.3)
						swait()
					end
					ws = 14
					dbwouldlovethis:Remove()
					attacking = false
				end)()
			end
		end
	end)


	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='u' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 6
				change = .5
				attacking = true
				slavdance = Instance.new("Sound",Torso)
				slavdance.SoundId = "rbxassetid://2341226836"
				slavdance.Volume = 6
				slavdance.Looped = true
				slavdance:Play()
				coroutine.wrap(function()
					while dancing do
						for i = 1, 17 do
							if not dancing then break end
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.52, 1.5, -.5) * CFrame.Angles(math.rad(-60), math.rad(0), math.rad(0)),.2)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.52, 1.2, .55) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)),.2)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.8 + .1 * math.sin(sine/3), 0) * CFrame.Angles(math.rad(22 - 2 * math.sin(sine/3)),math.rad(0),math.rad(0)),.2)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,-.2,.4) * CFrame.Angles(math.rad(-87 + .01 * math.sin(sine/9)),math.rad(80 - 3 * math.sin(sine/9)),math.rad(0)), 0.3)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.7,-.2,.4) * CFrame.Angles(math.rad(-87 - .01 * math.sin(sine/9)),math.rad(-88 + .7 * math.sin(sine/9)),math.rad(0)), 0.3)
							swait()
						end
						for i = 1, 17 do
							if not dancing then break end
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.52, 1.2, .55) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)),.2)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.52, 1.5, -.5) * CFrame.Angles(math.rad(-60), math.rad(0), math.rad(0)),.2)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.8 + .1 * math.sin(sine/3), 0) * CFrame.Angles(math.rad(22 - 2 * math.sin(sine/3)),math.rad(0),math.rad(0)),.2)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,-.2,.4) * CFrame.Angles(math.rad(-87 + .01 * math.sin(sine/9)),math.rad(80 - 3 * math.sin(sine/9)),math.rad(0)), 0.3)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.7,-.2,.4) * CFrame.Angles(math.rad(-87 - .01 * math.sin(sine/9)),math.rad(-88 + .7 * math.sin(sine/9)),math.rad(0)), 0.3)
							swait()
						end
						swait()
					end
					ws = 14
					slavdance:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='y' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				walkforward = 0
				walkrotation = 0
				attacking = true
				truelegend = Instance.new("Sound",Torso)
				truelegend.SoundId = "rbxassetid://487872908"
				truelegend.TimePosition = 13.98
				truelegend.Volume = 8
				truelegend.Looped = true
				truelegend:Play()
				coroutine.wrap(function()
					while dancing do
						for i = 1, 100 do
							if not dancing then break end
							walkforward = walkforward + .1
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2.05 , .1 * math.sin(sine/4)) * CFrame.Angles(math.rad(10 * math.sin(sine/4)), math.rad(0), math.rad(-8)), 0.3)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2.05, -.15 * math.sin(sine/4)) * CFrame.Angles(math.rad(-10 * math.sin(sine/4)), math.rad(0), math.rad(8)), 0.3)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.3)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.3)
							swait()
						end
						for i = 1, 50 do
							if not dancing then break end
							walkrotation = walkrotation + 15
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(walkrotation),math.rad(-0)),.2)
							swait()
						end
						walkrotation = 0
						for i = 1, 100 do
							if not dancing then break end
							walkforward = walkforward - .1
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2 , .1 * math.sin(sine/4)) * CFrame.Angles(math.rad(10 * math.sin(sine/4)), math.rad(0), math.rad(-8)), 0.3)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2, -.15 * math.sin(sine/4)) * CFrame.Angles(math.rad(-10 * math.sin(sine/4)), math.rad(0), math.rad(8)), 0.3)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(-180),math.rad(-0)),.2)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,.7,.2) * CFrame.Angles(math.rad(220),math.rad(0),math.rad(-30)), 0.4)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.3)
							swait()
						end
						for i = 1, 50 do
							if not dancing then break end
							walkrotation = walkrotation + 15
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.1)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(walkrotation),math.rad(-0)),.2)
							swait()
						end
						walkrotation = 0
						swait()
					end
					ws = 14
					truelegend:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='t' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				attacking = true
				plummusic = Instance.new("Sound",Torso)
				plummusic.Volume = 8
				plummusic.Looped = true
				plummusic.SoundId = "rbxassetid://2526093213"
				plummusic:Play()
				coroutine.wrap(function()
					while dancing do
						for i = 1, 20 do
							if not dancing then break end
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.33, 2 , .05) * CFrame.Angles(math.rad(3), math.rad(0), math.rad(-8)), 0.2)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.33, 2.0, -.05) * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(8)), 0.2)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0),math.rad(0*math.sin(sine/4)),math.rad(15)),.2)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(.5,1.98,.05) * CFrame.Angles(0,0,math.rad(-140)),.2)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,1.3,.05) * CFrame.Angles(0,0,math.rad(50)),.2)
							swait()
						end
						for i = 1, 20 do
							if not dancing then break end
							RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.33, 2, .05) * CFrame.Angles(math.rad(3), math.rad(0), math.rad(-8)), 0.2)
							LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.33, 2.0, -.05) * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(8)), 0.2)
							ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0),math.rad(0*math.sin(sine/4)),math.rad(-15)),.2)
							RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1,1.4,.05) * CFrame.Angles(0,0,math.rad(-50)),.2)
							LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(-.6,2,.05) * CFrame.Angles(0,0,math.rad(140)),.2)
							swait()
						end
						swait()
					end
					ws = 14
					plummusic:Remove()
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='e' then
			if dancing then
				dancing = false
			else
				dancing = true
				ws = 0
				change = .5
				attacking = true
				mrozo = Instance.new("Sound",Torso)
				mrozo.Volume = 8
				mrozo.SoundId = "rbxassetid://335701357"
				mrozo.Looped = true
				mrozo.TimePosition = 10
				mrozo:Play()
				coroutine.wrap(function()
					while dancing do
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , 0) * CFrame.Angles(0, math.rad(0), math.rad(-10)), 0.1)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10)), 0.1)
						ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0),math.rad(0*math.sin(sine/4)),math.rad(15*math.sin(sine/4))),.2)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3 + .3 * math.sin(sine/3.5),.5 * -math.sin(sine/3.5),.1) * CFrame.Angles(math.rad(0 * math.sin(sine/2)),0,math.rad(30 * math.sin(sine/3.5))),.2)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3 + .3 * math.sin(sine/3.5),.5 * math.sin(sine/3.5),.1) * CFrame.Angles(math.rad(0 * math.sin(sine/2)),0,math.rad(30 * math.sin(sine/3.5))),.2)
						swait()
					end
					mrozo:Remove()
					ws = 14
					attacking = false
				end)()
			end
		end
	end)

	mouse.KeyDown:connect(function(Press)
		Press=Press:lower()
		if Press=='r' then
			if dancing then
				dancing = false
			else
				ws = 6
				recordbaby = 0
				dancing = true
				change = .5
				attacking = true
				spinme = Instance.new("Sound",Torso)
				spinme.Volume = 8
				spinme.SoundId = "rbxassetid://145799973"
				spinme.Looped = true
				spinme:Play()
				coroutine.wrap(function()
					while dancing do
						recordbaby = recordbaby + 10
						RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.27, 2 , .1 * math.sin(sine/4)) * CFrame.Angles(math.rad(10 * math.sin(sine/4)), math.rad(0), math.rad(-8)), 0.3)
						LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.27, 2.0, -.1 * math.sin(sine/4)) * CFrame.Angles(math.rad(-10 * math.sin(sine/4)), math.rad(0), math.rad(8)), 0.3)
						ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(.5 * math.sin(sine/5), -.2, .5 * math.sin(sine/4)) * CFrame.Angles(math.rad(0),math.rad(recordbaby),math.rad(0)),.3)
						RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.5,1.98,0) * CFrame.Angles(0,0,math.rad(-90)),.3)
						LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.5,1.98,0) * CFrame.Angles(0,0,math.rad(90)),.3)
						swait()
					end
					spinme:Remove()
					ws = 14
					attacking = false
				end)()
			end
		end
	end)

	function ray(pos, dir, rang, ignoredesc)
		return workspace:FindPartOnRay(Ray.new(pos, dir.unit * rang), ignoredesc)
	end

	function ray2(startpos, endpos, distance, ignore)
		local dir = CFrame.new(startpos,endpos).lookVector
		return ray(startpos, dir, distance, ignore)
	end

	checks1 = coroutine.wrap(function() -------Checks
		while true do
			hf = ray(Root.Position,(CFrame.new(Root.Position,Root.Position+Vector3.new(0,-1,0))).lookVector,3*3,Character)
			if Root.Velocity.y > 1 then
				position = "Jump"
			elseif Root.Velocity.y < -1 then
				position = "Falling"
			elseif Root.Velocity.Magnitude < 2 then
				position = "Idle"
			elseif Root.Velocity.Magnitude > 2 then
				position = "Walking"
			elseif Root.Velocity.Magnitude > 20 then
				position = "Running"
			else
			end
			wait()
		end
	end)
	checks1()

	function ray(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end

	function ray2(StartPos, EndPos, Distance, Ignore)
		local DIRECTION = CFrame.new(StartPos,EndPos).lookVector
		return ray(StartPos, DIRECTION, Distance, Ignore)
	end

	OrgnC0 = Neck.C0
	local movelimbs = coroutine.wrap(function()
		while RunSrv.RenderStepped:wait() do
			TrsoLV = Torso.CFrame.lookVector
			Dist = nil
			Diff = nil
			if not MseGuide then
				print("Failed to recognize")
			else
				local _, Point = Workspace:FindPartOnRay(Ray.new(Head.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
				Dist = (Head.CFrame.p-Point).magnitude
				Diff = Head.CFrame.Y-Point.Y
				local _, Point2 = Workspace:FindPartOnRay(Ray.new(LeftArm.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
				Dist2 = (LeftArm.CFrame.p-Point).magnitude
				Diff2 = LeftArm.CFrame.Y-Point.Y
				HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
				Neck.C0 = Neck.C0:lerp(OrgnC0*CFrame.Angles((math.tan(Diff/Dist)*1), 0, (((Head.CFrame.p-Point).Unit):Cross(Torso.CFrame.lookVector)).Y*1), .1)
			end
		end
	end)
	movelimbs()
	immortal = {}
	for i,v in pairs(Character:GetDescendants()) do
		if v:IsA("BasePart") and v.Name ~= "lmagic" and v.Name ~= "rmagic" then
			if v ~= Root and v ~= Torso and v ~= Head and v ~= RightArm and v ~= LeftArm and v ~= RightLeg and v.Name ~= "lmagic" and v.Name ~= "rmagic" and v ~= LeftLeg then
				v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
			end
			table.insert(immortal,{v,v.Parent,v.Material,v.Color,v.Transparency})
		elseif v:IsA("JointInstance") then
			table.insert(immortal,{v,v.Parent,nil,nil,nil})
		end
	end
	for e = 1, #immortal do
		if immortal[e] ~= nil then
			local STUFF = immortal[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			if levitate then
				if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= eyo1 and PART.Name ~= eyo2 and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
					PART.Material = MATERIAL
					PART.Color = COLOR
					PART.Transparency = TRANSPARENCY
				end
				PART.AncestryChanged:connect(function()
					PART.Parent = PARENT
				end)
			else
				if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
					PART.Material = MATERIAL
					PART.Color = COLOR
					PART.Transparency = TRANSPARENCY
				end
				PART.AncestryChanged:connect(function()
					PART.Parent = PARENT
				end)
			end
		end
	end
	function immortality()
		for e = 1, #immortal do
			if immortal[e] ~= nil then
				local STUFF = immortal[e]
				local PART = STUFF[1]
				local PARENT = STUFF[2]
				local MATERIAL = STUFF[3]
				local COLOR = STUFF[4]
				local TRANSPARENCY = STUFF[5]
				if PART.ClassName == "Part" and PART == Root then
					PART.Material = MATERIAL
					PART.Color = COLOR
					PART.Transparency = TRANSPARENCY
				end
				if PART.Parent ~= PARENT then
					hum:Remove()
					PART.Parent = PARENT
					hum = Instance.new("Humanoid",Character)
					hum.Name = "noneofurbusiness"
				end
			end
		end
	end
	coroutine.wrap(function()
		while true do
			if hum.Health < .1 then
				deadsound = Instance.new("Sound", Torso)
				deadsound.Volume = 6
				deadsound.SoundId = "rbxassetid://1411352723"
				deadsound:Play()
				immortality()
			end
			wait()
		end
	end)()

	local anims = coroutine.wrap(function()
		while true do
			settime = 0.05
			sine = sine + change
			if position == "Jump" and attacking == false then
				change = 1
				spin = false
				for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
				LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
				RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
				LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
				ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
				LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(-3),math.rad(-4)), 0.2)
				RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.2)
				LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.2)
			elseif position == "Falling" and attacking == false then
				change = 1
				spin = false
				for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
				ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15), math.rad(0), math.rad(0)), 0.15)
				LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
				RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
				LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
				RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
				LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(-4), math.rad(0)), 0.2)
				LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.94 + .02 * math.sin(sine/12),-0) * CFrame.Angles(math.rad(28 + 5 * math.sin(sine/12)),math.rad(0),math.rad(45)), 0.2)
				RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.94 + .02 * math.sin(sine/12),-0) * CFrame.Angles(math.rad(28 + 5 * math.sin(sine/12)),math.rad(0),math.rad(-45)), 0.2)
			elseif position == "Walking" and attacking == false and running == false then
				change = 1.2
				walking = true
				spin = false
				for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
				RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5 + Root.RotVelocity.Y / 85,.35,-.5*math.sin(sine/11)) * CFrame.Angles(math.rad(35*math.sin(sine/11)),math.rad(0*math.sin(sine/11)),math.rad(-10 + Root.RotVelocity.Y / 10, math.sin(-20 * math.sin(sine/4)))),.3)
				LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5 + Root.RotVelocity.Y / 85,.45,.5*math.sin(sine/11)) * CFrame.Angles(math.rad(-55*math.sin(sine/11)),math.rad(-5*math.sin(sine/8)),math.rad(10 + Root.RotVelocity.Y / 10, math.sin(20 * math.sin(sine/4)))),.3)
				ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.15 * 0.6*-math.sin(sine/5.5), 0) * CFrame.Angles(math.rad(10), math.rad(12 * -math.sin(sine/11)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/10))), 0.3)
				RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/11)/2.8, -.2  + 0.2 - math.sin(sine/11)/3.4) * CFrame.Angles(math.rad(25 - 25) + -math.sin(sine/11)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0), math.cos(-15 * 25 * math.cos(sine/11))), 0.3)
				LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/11)/2.8, -.2 + 0.2 + math.sin(sine/11)/3.4) * CFrame.Angles(math.rad(25 - 25) - -math.sin(sine/11)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0) , math.cos(-15 * 25 * math.cos(sine/11))), 0.3)
			elseif position == "Idle" and attacking == false and running == false then
				change = .5
				spin = true
				for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
				ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine/12)),math.rad(0),math.rad(0)),.1)
				LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.27 + .02 * math.sin(sine/12),.20 * -math.sin(sine/12)) * CFrame.Angles(math.rad(20 * math.sin(sine/12)),math.rad(0),math.rad(10)), 0.1)
				RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.27 + .02 * math.sin(sine/12),.20 * -math.sin(sine/12)) * CFrame.Angles(math.rad(20 * math.sin(sine/12)),math.rad(0),math.rad(-10)), 0.1)
				RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine/12)), math.rad(0), math.rad(-10)), 0.1)
				LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine/12)), math.rad(0), math.rad(10)), 0.1)
			elseif position == "Running" and attacking == false then
				change = 1
				for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
				RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(0, .5, 0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), 0.3)
				LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-1.24+.6*math.sin(sine/4)/1.4, 0.54, 0-0.8*math.sin(sine/4))*CFrame.Angles(math.rad(6+140*math.sin(sine/4)/1.2), math.rad(0), math.rad(20+70*math.sin(sine/4))), 0.3)
				LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(0,.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
				ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(-20 - 0 * math.sin(sine/4)), math.rad(0 + 6 * math.sin(sine/4)), math.rad(0) + Root.RotVelocity.Y / 30, math.sin(10 * math.sin(sine/4))), 0.3)
				RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*-math.sin(sine/4)),.3)
				RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.6+0.1*math.sin(sine/4),.7*-math.sin(sine/4)) * CFrame.Angles(math.rad(15+ -50 * math.sin(sine/4)),0,0),.3)
				LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*math.sin(sine/4)),.3)
				LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.6-0.1*math.sin(sine/4),.7*math.sin(sine/4)) * CFrame.Angles(math.rad(15 + 50 * math.sin(sine/4)),0,0),.3)
			end
			swait()
		end
	end)
	anims()
	warn("Back from the past to dance the dance. Made by Supr14(Credits to Krystalteam).")

end)()

local Connection
Connection = game.Workspace.DescendantAdded:Connect(function(c)
	if c.Name == "Animate" and c.Parent == Player.Character then
		c.Enabled = false   
		Connection:Disconnect()
	end
end)
repeat task.wait() until game.Players.LocalPlayer.Character
task.wait(0.1)
local RealChar = Player.Character
RealChar.Archivable = true
FakeCharacter.Name = Player.Name .. "_Fake"
FakeCharacter.Parent = workspace
task.spawn(function()
	for i, LS in ipairs(FakeCharacter:GetChildren()) do
		if LS:IsA("LocalScript") then
			LS.Enabled = false
			task.wait(0.1)
			LS.Enabled = false
		end
	end
end)

for i, Part in ipairs(FakeCharacter:GetDescendants()) do
	if Part:IsA("BasePart")then
		Part.Transparency = 1
	end
end

for i, Decal in ipairs(FakeCharacter:GetDescendants()) do
	if Decal:IsA("Decal")then
		Decal.Transparency = 1
	end
end

Player.Character = FakeCharacter


local function MotorAngle()
	if RealChar:FindFirstChild("Torso") then
		for MotorName, Motor6DAngle in pairs(Motors) do
			if RealChar:FindFirstChild("Torso"):FindFirstChild(MotorName) then
				RealChar:FindFirstChild("Torso"):FindFirstChild(MotorName).CurrentAngle = Motor6DAngle
			end
		end
	end
end

local function SetAngles()
	if FakeCharacter:FindFirstChild("Torso") then
		for MotorName, Motor6DAngle in pairs(Motors) do
			if FakeCharacter:FindFirstChild("Torso"):FindFirstChild(MotorName) then
				local Motor = FakeCharacter:FindFirstChild("Torso"):FindFirstChild(MotorName) 
				local rx, ry, rz = Motor.Part1.CFrame:ToObjectSpace(FakeCharacter:FindFirstChild("Torso").CFrame):ToOrientation()
				--Motors[MotorName] = rx
				if Motor.Name == "Right Shoulder" then
					Motors[MotorName] = -rx
				end
				if Motor.Name == "Left Shoulder" then
					Motors[MotorName] = rx
				end
				if Motor.Name == "Right Hip" then
					Motors[MotorName] = -rx
				end
				if Motor.Name == "Left Hip" then
					Motors[MotorName] = rx
				end
				if Motor.Name == "Neck" then
					Motors[MotorName] = -ry
				end
			end
		end
	end
end

local KFFolder = Instance.new("Folder")
KFFolder.Parent = game.ReplicatedStorage

local function BaseCol()
	for i, Part in ipairs(RealChar:GetChildren()) do
		if Part:IsA("BasePart")then
			Part.CanCollide = false
		end
	end
	for i, Part in ipairs(FakeCharacter:GetChildren()) do
		if Part:IsA("BasePart")then
			Part.CanCollide = false
		end
	end
end

RunService.Heartbeat:Connect(function()
	SetAngles()
	MotorAngle()
	RealChar.HumanoidRootPart.CFrame = FakeCharacter.Torso.CFrame

end)

RunService.PreSimulation:Connect(function()
	BaseCol()
end)
