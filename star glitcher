--[[
made by sammyc and loadlua
gale fighter by makhail07

i didnt really do much besides fix the player not moving with the clientsided rig
and replacing the other script with gale fighter
with that being said i did not make this - MelonScripter
this script is not owned by me so it is open source
]]

local Motors = {
	["Left Hip"] = 0,
	["Neck"] = 0,
	["Left Shoulder"] = 0,
	["Right Hip"] = 0,
	["Right Shoulder"] = 0
}


local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local RunService = game:GetService("RunService")
game.Players.LocalPlayer.Character.Archivable = true
local FakeCharacter = game.Players.LocalPlayer.Character:Clone()
Player.Character:BreakJoints()
Player.Character=nil
coroutine.wrap(function()

	function LoadLibrary(a)
		local t = {}

		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------JSON Functions Begin----------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------

		--JSON Encoder and Parser for Lua 5.1
		-- 
		--Copyright 2007 Shaun Brown (http://www.chipmunkav.com)
		--All Rights Reserved.

		--Permission is hereby granted, free of charge, to any person
		--obtaining a copy of this software to deal in the Software without
		--restriction, including without limitation the rights to use,
		--copy, modify, merge, publish, distribute, sublicense, and/or
		--sell copies of the Software, and to permit persons to whom the
		--Software is furnished to do so, subject to the following conditions:

		--The above copyright notice and this permission notice shall be
		--included in all copies or substantial portions of the Software.
		--If you find this software useful please give www.chipmunkav.com a mention.

		--THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
		--EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
		--OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
		--IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
		--ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
		--CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
		--CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

		local string = string
		local math = math
		local table = table
		local error = error
		local tonumber = tonumber
		local tostring = tostring
		local type = type
		local setmetatable = setmetatable
		local pairs = pairs
		local ipairs = ipairs
		local assert = assert


		local StringBuilder = {
			buffer = {}
		}

		function StringBuilder:New()
			local o = {}
			setmetatable(o, self)
			self.__index = self
			o.buffer = {}
			return o
		end

		function StringBuilder:Append(s)
			self.buffer[#self.buffer+1] = s
		end

		function StringBuilder:ToString()
			return table.concat(self.buffer)
		end

		local JsonWriter = {
			backslashes = {
				['\b'] = "\\b",
				['\t'] = "\\t",
				['\n'] = "\\n",
				['\f'] = "\\f",
				['\r'] = "\\r",
				['"'] = "\\\"",
				['\\'] = "\\\\",
				['/'] = "\\/"
			}
		}

		function JsonWriter:New()
			local o = {}
			o.writer = StringBuilder:New()
			setmetatable(o, self)
			self.__index = self
			return o
		end

		function JsonWriter:Append(s)
			self.writer:Append(s)
		end

		function JsonWriter:ToString()
			return self.writer:ToString()
		end

		function JsonWriter:Write(o)
			local t = type(o)
			if t == "nil" then
				self:WriteNil()
			elseif t == "boolean" then
				self:WriteString(o)
			elseif t == "number" then
				self:WriteString(o)
			elseif t == "string" then
				self:ParseString(o)
			elseif t == "table" then
				self:WriteTable(o)
			elseif t == "function" then
				self:WriteFunction(o)
			elseif t == "thread" then
				self:WriteError(o)
			elseif t == "userdata" then
				self:WriteError(o)
			end
		end

		function JsonWriter:WriteNil()
			self:Append("null")
		end

		function JsonWriter:WriteString(o)
			self:Append(tostring(o))
		end

		function JsonWriter:ParseString(s)
			self:Append('"')
			self:Append(string.gsub(s, "[%z%c\\\"/]", function(n)
				local c = self.backslashes[n]
				if c then return c end
				return string.format("\\u%.4X", string.byte(n))
			end))
			self:Append('"')
		end

		function JsonWriter:IsArray(t)
			local count = 0
			local isindex = function(k)
				if type(k) == "number" and k > 0 then
					if math.floor(k) == k then
						return true
					end
				end
				return false
			end
			for k,v in pairs(t) do
				if not isindex(k) then
					return false, '{', '}'
				else
					count = math.max(count, k)
				end
			end
			return true, '[', ']', count
		end

		function JsonWriter:WriteTable(t)
			local ba, st, et, n = self:IsArray(t)
			self:Append(st)
			if ba then
				for i = 1, n do
					self:Write(t[i])
					if i < n then
						self:Append(',')
					end
				end
			else
				local first = true;
				for k, v in pairs(t) do
					if not first then
						self:Append(',')
					end
					first = false;
					self:ParseString(k)
					self:Append(':')
					self:Write(v)
				end
			end
			self:Append(et)
		end

		function JsonWriter:WriteError(o)
			error(string.format(
				"Encoding of %s unsupported",
				tostring(o)))
		end

		function JsonWriter:WriteFunction(o)
			if o == Null then
				self:WriteNil()
			else
				self:WriteError(o)
			end
		end

		local StringReader = {
			s = "",
			i = 0
		}

		function StringReader:New(s)
			local o = {}
			setmetatable(o, self)
			self.__index = self
			o.s = s or o.s
			return o
		end

		function StringReader:Peek()
			local i = self.i + 1
			if i <= #self.s then
				return string.sub(self.s, i, i)
			end
			return nil
		end

		function StringReader:Next()
			self.i = self.i+1
			if self.i <= #self.s then
				return string.sub(self.s, self.i, self.i)
			end
			return nil
		end

		function StringReader:All()
			return self.s
		end

		local JsonReader = {
			escapes = {
				['t'] = '\t',
				['n'] = '\n',
				['f'] = '\f',
				['r'] = '\r',
				['b'] = '\b',
			}
		}

		function JsonReader:New(s)
			local o = {}
			o.reader = StringReader:New(s)
			setmetatable(o, self)
			self.__index = self
			return o;
		end

		function JsonReader:Read()
			self:SkipWhiteSpace()
			local peek = self:Peek()
			if peek == nil then
				error(string.format(
					"Nil string: '%s'",
					self:All()))
			elseif peek == '{' then
				return self:ReadObject()
			elseif peek == '[' then
				return self:ReadArray()
			elseif peek == '"' then
				return self:ReadString()
			elseif string.find(peek, "[%+%-%d]") then
				return self:ReadNumber()
			elseif peek == 't' then
				return self:ReadTrue()
			elseif peek == 'f' then
				return self:ReadFalse()
			elseif peek == 'n' then
				return self:ReadNull()
			elseif peek == '/' then
				self:ReadComment()
				return self:Read()
			else
				return nil
			end
		end

		function JsonReader:ReadTrue()
			self:TestReservedWord{'t','r','u','e'}
			return true
		end

		function JsonReader:ReadFalse()
			self:TestReservedWord{'f','a','l','s','e'}
			return false
		end

		function JsonReader:ReadNull()
			self:TestReservedWord{'n','u','l','l'}
			return nil
		end

		function JsonReader:TestReservedWord(t)
			for i, v in ipairs(t) do
				if self:Next() ~= v then
					error(string.format(
						"Error reading '%s': %s",
						table.concat(t),
						self:All()))
				end
			end
		end

		function JsonReader:ReadNumber()
			local result = self:Next()
			local peek = self:Peek()
			while peek ~= nil and string.find(
				peek,
				"[%+%-%d%.eE]") do
				result = result .. self:Next()
				peek = self:Peek()
			end
			result = tonumber(result)
			if result == nil then
				error(string.format(
					"Invalid number: '%s'",
					result))
			else
				return result
			end
		end

		function JsonReader:ReadString()
			local result = ""
			assert(self:Next() == '"')
			while self:Peek() ~= '"' do
				local ch = self:Next()
				if ch == '\\' then
					ch = self:Next()
					if self.escapes[ch] then
						ch = self.escapes[ch]
					end
				end
				result = result .. ch
			end
			assert(self:Next() == '"')
			local fromunicode = function(m)
				return string.char(tonumber(m, 16))
			end
			return string.gsub(
				result,
				"u%x%x(%x%x)",
				fromunicode)
		end

		function JsonReader:ReadComment()
			assert(self:Next() == '/')
			local second = self:Next()
			if second == '/' then
				self:ReadSingleLineComment()
			elseif second == '*' then
				self:ReadBlockComment()
			else
				error(string.format(
					"Invalid comment: %s",
					self:All()))
			end
		end

		function JsonReader:ReadBlockComment()
			local done = false
			while not done do
				local ch = self:Next()
				if ch == '*' and self:Peek() == '/' then
					done = true
				end
				if not done and
					ch == '/' and
					self:Peek() == "*" then
					error(string.format(
						"Invalid comment: %s, '/*' illegal.",
						self:All()))
				end
			end
			self:Next()
		end

		function JsonReader:ReadSingleLineComment()
			local ch = self:Next()
			while ch ~= '\r' and ch ~= '\n' do
				ch = self:Next()
			end
		end

		function JsonReader:ReadArray()
			local result = {}
			assert(self:Next() == '[')
			local done = false
			if self:Peek() == ']' then
				done = true;
			end
			while not done do
				local item = self:Read()
				result[#result+1] = item
				self:SkipWhiteSpace()
				if self:Peek() == ']' then
					done = true
				end
				if not done then
					local ch = self:Next()
					if ch ~= ',' then
						error(string.format(
							"Invalid array: '%s' due to: '%s'",
							self:All(), ch))
					end
				end
			end
			assert(']' == self:Next())
			return result
		end

		function JsonReader:ReadObject()
			local result = {}
			assert(self:Next() == '{')
			local done = false
			if self:Peek() == '}' then
				done = true
			end
			while not done do
				local key = self:Read()
				if type(key) ~= "string" then
					error(string.format(
						"Invalid non-string object key: %s",
						key))
				end
				self:SkipWhiteSpace()
				local ch = self:Next()
				if ch ~= ':' then
					error(string.format(
						"Invalid object: '%s' due to: '%s'",
						self:All(),
						ch))
				end
				self:SkipWhiteSpace()
				local val = self:Read()
				result[key] = val
				self:SkipWhiteSpace()
				if self:Peek() == '}' then
					done = true
				end
				if not done then
					ch = self:Next()
					if ch ~= ',' then
						error(string.format(
							"Invalid array: '%s' near: '%s'",
							self:All(),
							ch))
					end
				end
			end
			assert(self:Next() == "}")
			return result
		end

		function JsonReader:SkipWhiteSpace()
			local p = self:Peek()
			while p ~= nil and string.find(p, "[%s/]") do
				if p == '/' then
					self:ReadComment()
				else
					self:Next()
				end
				p = self:Peek()
			end
		end

		function JsonReader:Peek()
			return self.reader:Peek()
		end

		function JsonReader:Next()
			return self.reader:Next()
		end

		function JsonReader:All()
			return self.reader:All()
		end

		function Encode(o)
			local writer = JsonWriter:New()
			writer:Write(o)
			return writer:ToString()
		end

		function Decode(s)
			local reader = JsonReader:New(s)
			return reader:Read()
		end

		function Null()
			return Null
		end
		-------------------- End JSON Parser ------------------------

		t.DecodeJSON = function(jsonString)
			pcall(function() warn("RbxUtility.DecodeJSON is deprecated, please use Game:GetService('HttpService'):JSONDecode() instead.") end)

			if type(jsonString) == "string" then
				return Decode(jsonString)
			end
			print("RbxUtil.DecodeJSON expects string argument!")
			return nil
		end

		t.EncodeJSON = function(jsonTable)
			pcall(function() warn("RbxUtility.EncodeJSON is deprecated, please use Game:GetService('HttpService'):JSONEncode() instead.") end)
			return Encode(jsonTable)
		end








		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		--------------------------------------------Terrain Utilities Begin-----------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		--makes a wedge at location x, y, z
		--sets cell x, y, z to default material if parameter is provided, if not sets cell x, y, z to be whatever material it previously w
		--returns true if made a wedge, false if the cell remains a block
		t.MakeWedge = function(x, y, z, defaultmaterial)
			return game:GetService("Terrain"):AutoWedgeCell(x,y,z)
		end

		t.SelectTerrainRegion = function(regionToSelect, color, selectEmptyCells, selectionParent)
			local terrain = game:GetService("Workspace"):FindFirstChild("Terrain")
			if not terrain then return end

			assert(regionToSelect)
			assert(color)

			if not type(regionToSelect) == "Region3" then
				error("regionToSelect (first arg), should be of type Region3, but is type",type(regionToSelect))
			end
			if not type(color) == "BrickColor" then
				error("color (second arg), should be of type BrickColor, but is type",type(color))
			end

			-- frequently used terrain calls (speeds up call, no lookup necessary)
			local GetCell = terrain.GetCell
			local WorldToCellPreferSolid = terrain.WorldToCellPreferSolid
			local CellCenterToWorld = terrain.CellCenterToWorld
			local emptyMaterial = Enum.CellMaterial.Empty

			-- container for all adornments, passed back to user
			local selectionContainer = Instance.new("Model")
			selectionContainer.Name = "SelectionContainer"
			selectionContainer.Archivable = false
			if selectionParent then
				selectionContainer.Parent = selectionParent
			else
				selectionContainer.Parent = game:GetService("Workspace")
			end

			local updateSelection = nil -- function we return to allow user to update selection
			local currentKeepAliveTag = nil -- a tag that determines whether adorns should be destroyed
			local aliveCounter = 0 -- helper for currentKeepAliveTag
			local lastRegion = nil -- used to stop updates that do nothing
			local adornments = {} -- contains all adornments
			local reusableAdorns = {}

			local selectionPart = Instance.new("Part")
			selectionPart.Name = "SelectionPart"
			selectionPart.Transparency = 1
			selectionPart.Anchored = true
			selectionPart.Locked = true
			selectionPart.CanCollide = false
			selectionPart.Size = Vector3.new(4.2,4.2,4.2)

			local selectionBox = Instance.new("SelectionBox")

			-- srs translation from region3 to region3int16
			local function Region3ToRegion3int16(region3)
				local theLowVec = region3.CFrame.p - (region3.Size/2) + Vector3.new(2,2,2)
				local lowCell = WorldToCellPreferSolid(terrain,theLowVec)

				local theHighVec = region3.CFrame.p + (region3.Size/2) - Vector3.new(2,2,2)
				local highCell = WorldToCellPreferSolid(terrain, theHighVec)

				local highIntVec = Vector3int16.new(highCell.x,highCell.y,highCell.z)
				local lowIntVec = Vector3int16.new(lowCell.x,lowCell.y,lowCell.z)

				return Region3int16.new(lowIntVec,highIntVec)
			end

			-- helper function that creates the basis for a selection box
			function createAdornment(theColor)
				local selectionPartClone = nil
				local selectionBoxClone = nil

				if #reusableAdorns > 0 then
					selectionPartClone = reusableAdorns[1]["part"]
					selectionBoxClone = reusableAdorns[1]["box"]
					table.remove(reusableAdorns,1)

					selectionBoxClone.Visible = true
				else
					selectionPartClone = selectionPart:Clone()
					selectionPartClone.Archivable = false

					selectionBoxClone = selectionBox:Clone()
					selectionBoxClone.Archivable = false

					selectionBoxClone.Adornee = selectionPartClone
					selectionBoxClone.Parent = selectionContainer

					selectionBoxClone.Adornee = selectionPartClone

					selectionBoxClone.Parent = selectionContainer
				end

				if theColor then
					selectionBoxClone.Color = theColor
				end

				return selectionPartClone, selectionBoxClone
			end

			-- iterates through all current adornments and deletes any that don't have latest tag
			function cleanUpAdornments()
				for cellPos, adornTable in pairs(adornments) do

					if adornTable.KeepAlive ~= currentKeepAliveTag then -- old news, we should get rid of this
						adornTable.SelectionBox.Visible = false
						table.insert(reusableAdorns,{part = adornTable.SelectionPart, box = adornTable.SelectionBox})
						adornments[cellPos] = nil
					end
				end
			end

			-- helper function to update tag
			function incrementAliveCounter()
				aliveCounter = aliveCounter + 1
				if aliveCounter > 1000000 then
					aliveCounter = 0
				end
				return aliveCounter
			end

			-- finds full cells in region and adorns each cell with a box, with the argument color
			function adornFullCellsInRegion(region, color)
				local regionBegin = region.CFrame.p - (region.Size/2) + Vector3.new(2,2,2)
				local regionEnd = region.CFrame.p + (region.Size/2) - Vector3.new(2,2,2)

				local cellPosBegin = WorldToCellPreferSolid(terrain, regionBegin)
				local cellPosEnd = WorldToCellPreferSolid(terrain, regionEnd)

				currentKeepAliveTag = incrementAliveCounter()
				for y = cellPosBegin.y, cellPosEnd.y do
					for z = cellPosBegin.z, cellPosEnd.z do
						for x = cellPosBegin.x, cellPosEnd.x do
							local cellMaterial = GetCell(terrain, x, y, z)

							if cellMaterial ~= emptyMaterial then
								local cframePos = CellCenterToWorld(terrain, x, y, z)
								local cellPos = Vector3int16.new(x,y,z)

								local updated = false
								for cellPosAdorn, adornTable in pairs(adornments) do
									if cellPosAdorn == cellPos then
										adornTable.KeepAlive = currentKeepAliveTag
										if color then
											adornTable.SelectionBox.Color = color
										end
										updated = true
										break
									end
								end

								if not updated then
									local selectionPart, selectionBox = createAdornment(color)
									selectionPart.Size = Vector3.new(4,4,4)
									selectionPart.CFrame = CFrame.new(cframePos)
									local adornTable = {SelectionPart = selectionPart, SelectionBox = selectionBox, KeepAlive = currentKeepAliveTag}
									adornments[cellPos] = adornTable
								end
							end
						end
					end
				end
				cleanUpAdornments()
			end


			------------------------------------- setup code ------------------------------
			lastRegion = regionToSelect

			if selectEmptyCells then -- use one big selection to represent the area selected
				local selectionPart, selectionBox = createAdornment(color)

				selectionPart.Size = regionToSelect.Size
				selectionPart.CFrame = regionToSelect.CFrame

				adornments.SelectionPart = selectionPart
				adornments.SelectionBox = selectionBox

				updateSelection =
					function (newRegion, color)
						if newRegion and newRegion ~= lastRegion then
						lastRegion = newRegion
						selectionPart.Size = newRegion.Size
						selectionPart.CFrame = newRegion.CFrame
					end
						if color then
						selectionBox.Color = color
					end
					end
			else -- use individual cell adorns to represent the area selected
				adornFullCellsInRegion(regionToSelect, color)
				updateSelection =
					function (newRegion, color)
						if newRegion and newRegion ~= lastRegion then
						lastRegion = newRegion
						adornFullCellsInRegion(newRegion, color)
					end
					end

			end

			local destroyFunc = function()
				updateSelection = nil
				if selectionContainer then selectionContainer:Destroy() end
				adornments = nil
			end

			return updateSelection, destroyFunc
		end

		-----------------------------Terrain Utilities End-----------------------------







		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------Signal class begin------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
--[[
A 'Signal' object identical to the internal RBXScriptSignal object in it's public API and semantics. This function
can be used to create "custom events" for user-made code.
API:
Method :connect( function handler )
Arguments: The function to connect to.
Returns: A new connection object which can be used to disconnect the connection
Description: Connects this signal to the function specified by |handler|. That is, when |fire( ... )| is called for
the signal the |handler| will be called with the arguments given to |fire( ... )|. Note, the functions
connected to a signal are called in NO PARTICULAR ORDER, so connecting one function after another does
NOT mean that the first will be called before the second as a result of a call to |fire|.
 
Method :disconnect()
Arguments: None
Returns: None
Description: Disconnects all of the functions connected to this signal.
 
Method :fire( ... )
Arguments: Any arguments are accepted
Returns: None
Description: Calls all of the currently connected functions with the given arguments.
 
Method :wait()
Arguments: None
Returns: The arguments given to fire
Description: This call blocks until
]]

		function t.CreateSignal()
			local this = {}

			local mBindableEvent = Instance.new('BindableEvent')
			local mAllCns = {} --all connection objects returned by mBindableEvent::connect

			--main functions
			function this:connect(func)
				if self ~= this then error("connect must be called with `:`, not `.`", 2) end
				if type(func) ~= 'function' then
					error("Argument #1 of connect must be a function, got a "..type(func), 2)
				end
				local cn = mBindableEvent.Event:Connect(func)
				mAllCns[cn] = true
				local pubCn = {}
				function pubCn:disconnect()
					cn:Disconnect()
					mAllCns[cn] = nil
				end
				pubCn.Disconnect = pubCn.disconnect

				return pubCn
			end

			function this:disconnect()
				if self ~= this then error("disconnect must be called with `:`, not `.`", 2) end
				for cn, _ in pairs(mAllCns) do
					cn:Disconnect()
					mAllCns[cn] = nil
				end
			end

			function this:wait()
				if self ~= this then error("wait must be called with `:`, not `.`", 2) end
				return mBindableEvent.Event:Wait()
			end

			function this:fire(...)
				if self ~= this then error("fire must be called with `:`, not `.`", 2) end
				mBindableEvent:Fire(...)
			end

			this.Connect = this.connect
			this.Disconnect = this.disconnect
			this.Wait = this.wait
			this.Fire = this.fire

			return this
		end

		------------------------------------------------- Sigal class End ------------------------------------------------------




		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		-----------------------------------------------Create Function Begins---------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
--[[
A "Create" function for easy creation of Roblox instances. The function accepts a string which is the classname of
the object to be created. The function then returns another function which either accepts accepts no arguments, in
which case it simply creates an object of the given type, or a table argument that may contain several types of data,
in which case it mutates the object in varying ways depending on the nature of the aggregate data. These are the
type of data and what operation each will perform:
1) A string key mapping to some value:
Key-Value pairs in this form will be treated as properties of the object, and will be assigned in NO PARTICULAR
ORDER. If the order in which properties is assigned matter, then they must be assigned somewhere else than the
|Create| call's body.
 
2) An integral key mapping to another Instance:
Normal numeric keys mapping to Instances will be treated as children if the object being created, and will be
parented to it. This allows nice recursive calls to Create to create a whole hierarchy of objects without a
need for temporary variables to store references to those objects.
 
3) A key which is a value returned from Create.Event( eventname ), and a value which is a function function
The Create.E( string ) function provides a limited way to connect to signals inside of a Create hierarchy
for those who really want such a functionality. The name of the event whose name is passed to
Create.E( string )
 
4) A key which is the Create function itself, and a value which is a function
The function will be run with the argument of the object itself after all other initialization of the object is
done by create. This provides a way to do arbitrary things involving the object from withing the create
hierarchy.
Note: This function is called SYNCHRONOUSLY, that means that you should only so initialization in
it, not stuff which requires waiting, as the Create call will block until it returns. While waiting in the
constructor callback function is possible, it is probably not a good design choice.
Note: Since the constructor function is called after all other initialization, a Create block cannot have two
constructor functions, as it would not be possible to call both of them last, also, this would be unnecessary.
 
 
Some example usages:
 
A simple example which uses the Create function to create a model object and assign two of it's properties.
local model = Create'Model'{
Name = 'A New model',
Parent = game.Workspace,
}
 
 
An example where a larger hierarchy of object is made. After the call the hierarchy will look like this:
Model_Container
|-ObjectValue
| |
| `-BoolValueChild
`-IntValue
 
local model = Create'Model'{
Name = 'Model_Container',
Create'ObjectValue'{
Create'BoolValue'{
Name = 'BoolValueChild',
},
},
Create'IntValue'{},
}
 
 
An example using the event syntax:
 
local part = Create'Part'{
[Create.E'Touched'] = function(part)
print("I was touched by "..part.Name)
end,
}
 
 
An example using the general constructor syntax:
 
local model = Create'Part'{
[Create] = function(this)
print("Constructor running!")
this.Name = GetGlobalFoosAndBars(this)
end,
}
 
 
Note: It is also perfectly legal to save a reference to the function returned by a call Create, this will not cause
any unexpected behavior. EG:
local partCreatingFunction = Create'Part'
local part = partCreatingFunction()
]]

		--the Create function need to be created as a functor, not a function, in order to support the Create.E syntax, so it
		--will be created in several steps rather than as a single function declaration.
		local function Create_PrivImpl(objectType)
			if type(objectType) ~= 'string' then
				error("Argument of Create must be a string", 2)
			end
			--return the proxy function that gives us the nice Create'string'{data} syntax
			--The first function call is a function call using Lua's single-string-argument syntax
			--The second function call is using Lua's single-table-argument syntax
			--Both can be chained together for the nice effect.
			return function(dat)
				--default to nothing, to handle the no argument given case
				dat = dat or {}

				--make the object to mutate
				local obj = Instance.new(objectType)
				local parent = nil

				--stored constructor function to be called after other initialization
				local ctor = nil

				for k, v in pairs(dat) do
					--add property
					if type(k) == 'string' then
						if k == 'Parent' then
							-- Parent should always be set last, setting the Parent of a new object
							-- immediately makes performance worse for all subsequent property updates.
							parent = v
						else
							obj[k] = v
						end


						--add child
					elseif type(k) == 'number' then
						if type(v) ~= 'userdata' then
							error("Bad entry in Create body: Numeric keys must be paired with children, got a: "..type(v), 2)
						end
						v.Parent = obj


						--event connect
					elseif type(k) == 'table' and k.__eventname then
						if type(v) ~= 'function' then
							error("Bad entry in Create body: Key `[Create.E\'"..k.__eventname.."\']` must have a function value\
got: "..tostring(v), 2)
						end
						obj[k.__eventname]:connect(v)


						--define constructor function
					elseif k == t.Create then
						if type(v) ~= 'function' then
							error("Bad entry in Create body: Key `[Create]` should be paired with a constructor function, \
got: "..tostring(v), 2)
						elseif ctor then
							--ctor already exists, only one allowed
							error("Bad entry in Create body: Only one constructor function is allowed", 2)
						end
						ctor = v


					else
						error("Bad entry ("..tostring(k).." => "..tostring(v)..") in Create body", 2)
					end
				end

				--apply constructor function if it exists
				if ctor then
					ctor(obj)
				end

				if parent then
					obj.Parent = parent
				end

				--return the completed object
				return obj
			end
		end

		--now, create the functor:
		t.Create = setmetatable({}, {__call = function(tb, ...) return Create_PrivImpl(...) end})

		--and create the "Event.E" syntax stub. Really it's just a stub to construct a table which our Create
		--function can recognize as special.
		t.Create.E = function(eventName)
			return {__eventname = eventName}
		end

		-------------------------------------------------Create function End----------------------------------------------------




		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------Documentation Begin-----------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------

		t.Help =
			function(funcNameOrFunc)
				--input argument can be a string or a function. Should return a description (of arguments and expected side effects)
				if funcNameOrFunc == "DecodeJSON" or funcNameOrFunc == t.DecodeJSON then
				return "Function DecodeJSON. " ..
					"Arguments: (string). " ..
					"Side effect: returns a table with all parsed JSON values"
			end
				if funcNameOrFunc == "EncodeJSON" or funcNameOrFunc == t.EncodeJSON then
				return "Function EncodeJSON. " ..
					"Arguments: (table). " ..
					"Side effect: returns a string composed of argument table in JSON data format"
			end
				if funcNameOrFunc == "MakeWedge" or funcNameOrFunc == t.MakeWedge then
				return "Function MakeWedge. " ..
					"Arguments: (x, y, z, [default material]). " ..
					"Description: Makes a wedge at location x, y, z. Sets cell x, y, z to default material if "..
					"parameter is provided, if not sets cell x, y, z to be whatever material it previously was. "..
					"Returns true if made a wedge, false if the cell remains a block "
			end
				if funcNameOrFunc == "SelectTerrainRegion" or funcNameOrFunc == t.SelectTerrainRegion then
				return "Function SelectTerrainRegion. " ..
					"Arguments: (regionToSelect, color, selectEmptyCells, selectionParent). " ..
					"Description: Selects all terrain via a series of selection boxes within the regionToSelect " ..
					"(this should be a region3 value). The selection box color is detemined by the color argument " ..
					"(should be a brickcolor value). SelectionParent is the parent that the selection model gets placed to (optional)." ..
					"SelectEmptyCells is bool, when true will select all cells in the " ..
					"region, otherwise we only select non-empty cells. Returns a function that can update the selection," ..
					"arguments to said function are a new region3 to select, and the adornment color (color arg is optional). " ..
					"Also returns a second function that takes no arguments and destroys the selection"
			end
				if funcNameOrFunc == "CreateSignal" or funcNameOrFunc == t.CreateSignal then
				return "Function CreateSignal. "..
					"Arguments: None. "..
					"Returns: The newly created Signal object. This object is identical to the RBXScriptSignal class "..
					"used for events in Objects, but is a Lua-side object so it can be used to create custom events in"..
					"Lua code. "..
					"Methods of the Signal object: :connect, :wait, :fire, :disconnect. "..
					"For more info you can pass the method name to the Help function, or view the wiki page "..
					"for this library. EG: Help('Signal:connect')."
			end
				if funcNameOrFunc == "Signal:connect" then
				return "Method Signal:connect. "..
					"Arguments: (function handler). "..
					"Return: A connection object which can be used to disconnect the connection to this handler. "..
					"Description: Connectes a handler function to this Signal, so that when |fire| is called the "..
					"handler function will be called with the arguments passed to |fire|."
			end
				if funcNameOrFunc == "Signal:wait" then
				return "Method Signal:wait. "..
					"Arguments: None. "..
					"Returns: The arguments passed to the next call to |fire|. "..
					"Description: This call does not return until the next call to |fire| is made, at which point it "..
					"will return the values which were passed as arguments to that |fire| call."
			end
				if funcNameOrFunc == "Signal:fire" then
				return "Method Signal:fire. "..
					"Arguments: Any number of arguments of any type. "..
					"Returns: None. "..
					"Description: This call will invoke any connected handler functions, and notify any waiting code "..
					"attached to this Signal to continue, with the arguments passed to this function. Note: The calls "..
					"to handlers are made asynchronously, so this call will return immediately regardless of how long "..
					"it takes the connected handler functions to complete."
			end
				if funcNameOrFunc == "Signal:disconnect" then
				return "Method Signal:disconnect. "..
					"Arguments: None. "..
					"Returns: None. "..
					"Description: This call disconnects all handlers attacched to this function, note however, it "..
					"does NOT make waiting code continue, as is the behavior of normal Roblox events. This method "..
					"can also be called on the connection object which is returned from Signal:connect to only "..
					"disconnect a single handler, as opposed to this method, which will disconnect all handlers."
			end
				if funcNameOrFunc == "Create" then
				return "Function Create. "..
					"Arguments: A table containing information about how to construct a collection of objects. "..
					"Returns: The constructed objects. "..
					"Descrition: Create is a very powerfull function, whose description is too long to fit here, and "..
					"is best described via example, please see the wiki page for a description of how to use it."
			end
			end

		--------------------------------------------Documentation Ends----------------------------------------------------------

		return t
	end

	warn("Star Glitcher Loaded.")
	warn("All purpose switcher...")
	warn("Edit By Frepix.")
	warn("Minor Edit By UndeniableInfinity.")
	warn("Please Support The Original Creator Of This Script.")
	plr = game.Players.LocalPlayer
	char = FakeCharacter
	hum = char.Humanoid
	local cam = game.Workspace.CurrentCamera
	--local Controller = plr.PlayerScripts:WaitForChild("ControlScript")
	Camera = cam
	local CamInterrupt = false
	local TwoD = false
	local TargetInfo = {nil, nil}
	cam.CameraType = "Custom"
	t = char.Torso
	h = char.Head
	ra = char["Right Arm"]
	la = char["Left Arm"]
	rl = char["Right Leg"]
	ll = char["Left Leg"]
	tors = char.Torso
	lleg = char["Left Leg"]
	root = char.HumanoidRootPart
	hed = char.Head
	rleg = char["Right Leg"]
	rarm = char["Right Arm"]
	larm = char["Left Arm"]
	radian = math.rad
	random = math.random
	Vec3 = Vector3.new
	Inst = Instance.new
	cFrame = CFrame.new
	Euler = CFrame.fromEulerAnglesXYZ
	vt = Vector3.new
	bc = BrickColor.new
	br = BrickColor.random
	it = Instance.new
	cf = CFrame.new
	local Booleans = {CamFollow = true, GyroUse = true}
	function lerp(object, newCFrame, alpha)
		return object:lerp(newCFrame, alpha)
	end

	ff = Instance.new("ForceField", game.Players.LocalPlayer.Character)
	ff.Visible = false


	local Directer = Inst("BodyGyro", root)
	Directer.MaxTorque = Vec3(0, 0, 0)
	Directer.P = 600000
	local CPart = Inst("Part")
	CPart.Anchored = true
	CPart.CanCollide = false
	CPart.Locked = true
	CPart.Transparency = 1
	local rainbowmode = false
	local chaosmode = false
	kan = Instance.new("Sound", char)
	kan.Volume = 1.98
	kan.TimePosition = 0
	kan.PlaybackSpeed = 1
	kan.Pitch = 1
	kan.SoundId = "rbxassetid://415898123"
	kan.Name = "wrecked"
	kan.Looped = true
	kan:Play()
	function newTheme(ID, timepos, pitch, vol)
		local kanz = kan
		kanz.PlaybackSpeed = pitch
		kanz.Pitch = pitch
		kanz.SoundId = ID
		kanz.Name = "wrecked"
		kanz.Looped = true
	end
	function CameraShake(Times, Power, PlayerTarget)
		coroutine.resume(coroutine.create(function()
			FV = Instance.new("BoolValue", PlayerTarget)
			FV.Name = "CameraShake"
			for ShakeNum = 1, Times do
				swait()
				local ef = Power
				if ef >= 1 then
					Humanoid.CameraOffset = Vector3.new(math.random(-ef, ef), math.random(-ef, ef), math.random(-ef, ef))
				else
					ef = Power * 10
					Humanoid.CameraOffset = Vector3.new(math.random(-ef, ef) / 10, math.random(-ef, ef) / 10, math.random(-ef, ef) / 10)
				end
			end
			Humanoid.CameraOffset = Vector3.new(0, 0, 0)
			FV:Destroy()
		end))
	end
	function CameraEnshaking(Length, Intensity)
		coroutine.resume(coroutine.create(function()
			local intensity = 1 * Intensity
			local rotM = 0.01 * Intensity
			for i = 0, Length, 0.1 do
				swait()
				intensity = intensity - 0.05 * Intensity / Length
				rotM = rotM - 5.0E-4 * Intensity / Length
				hum.CameraOffset = Vec3(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity)))
				cam.CFrame = cam.CFrame * cFrame(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity))) * Euler(radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM)
			end
			Humanoid.CameraOffset = Vec3(0, 0, 0)
		end))
	end
	function CamShake(Part, Distan, Power, Times)
		local de = Part.Position
		for i, v in pairs(workspace:children()) do
			if v:IsA("Model") and v:findFirstChild("Humanoid") then
				for _, c in pairs(v:children()) do
					if c.ClassName == "Part" and Distan > (c.Position - de).magnitude then
						do
							local Noob = v.Humanoid
							if Noob ~= nil then
								coroutine.resume(coroutine.create(function()
									FV = Instance.new("BoolValue", Noob)
									FV.Name = "CameraShake"
									for ShakeNum = 1, Times do
										swait()
										local ef = Power
										if ef >= 1 then
											Humanoid.CameraOffset = Vector3.new(math.random(-ef, ef), math.random(-ef, ef), math.random(-ef, ef))
										else
											ef = Power * 10
											Humanoid.CameraOffset = Vector3.new(math.random(-ef, ef) / 10, math.random(-ef, ef) / 10, math.random(-ef, ef) / 10)
										end
									end
									Humanoid.CameraOffset = Vector3.new(0, 0, 0)
									FV:Destroy()
								end))
								CameraShake(Times, Power, Noob)
							end
						end
					end
				end
			end
		end
	end
	function chatfunc(text, color)
		local chat = coroutine.wrap(function()
			if Character:FindFirstChild("TalkingBillBoard") ~= nil then
				Character:FindFirstChild("TalkingBillBoard"):destroy()
			end
			local naeeym2 = Instance.new("BillboardGui", Character)
			naeeym2.Size = UDim2.new(0, 100, 0, 40)
			naeeym2.StudsOffset = Vector3.new(0, 3, 0)
			naeeym2.Adornee = Character.Head
			naeeym2.Name = "TalkingBillBoard"
			local tecks2 = Instance.new("TextLabel", naeeym2)
			tecks2.BackgroundTransparency = 1
			tecks2.BorderSizePixel = 0
			tecks2.Text = ""
			tecks2.Font = "SciFi"
			tecks2.TextSize = 30
			tecks2.TextStrokeTransparency = 0
			tecks2.TextColor3 = color
			tecks2.TextStrokeColor3 = Color3.new(0, 0, 0)
			tecks2.Size = UDim2.new(1, 0, 0.5, 0)
			local tecks3 = Instance.new("TextLabel", naeeym2)
			tecks3.BackgroundTransparency = 1
			tecks3.BorderSizePixel = 0
			tecks3.Text = ""
			tecks3.Font = "SciFi"
			tecks3.TextSize = 30
			tecks3.TextStrokeTransparency = 0
			tecks3.TextColor3 = Color3.new(0, 0, 0)
			tecks3.TextStrokeColor3 = color
			tecks3.Size = UDim2.new(1, 0, 0.5, 0)
			coroutine.resume(coroutine.create(function()
				while true do
					swait(1)
					if chaosmode == true then
						tecks2.TextColor3 = BrickColor.random().Color
						tecks3.TextStrokeColor3 = BrickColor.random().Color
					end
					tecks2.Position = UDim2.new(0, math.random(-5, 5), 0, math.random(-5, 5))
					tecks3.Position = UDim2.new(0, math.random(-5, 5), 0, math.random(-5, 5))
					tecks2.Rotation = math.random(-5, 5)
					tecks3.Rotation = math.random(-5, 5)
				end
			end))
			for i = 1, string.len(text) do
				CFuncs.Sound.Create("rbxassetid://274118116", char, 0.25, 0.115)
				tecks2.Text = string.sub(text, 1, i)
				tecks3.Text = string.sub(text, 1, i)
				swait(1)
			end
			wait(1)
			local randomrot = math.random(1, 2)
			if randomrot == 1 then
				for i = 1, 50 do
					swait()
					tecks2.Rotation = tecks2.Rotation - 0.75
					tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency + 0.04
					tecks2.TextTransparency = tecks2.TextTransparency + 0.04
					tecks3.Rotation = tecks2.Rotation + 0.75
					tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency + 0.04
					tecks3.TextTransparency = tecks2.TextTransparency + 0.04
				end
			elseif randomrot == 2 then
				for i = 1, 50 do
					swait()
					tecks2.Rotation = tecks2.Rotation + 0.75
					tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency + 0.04
					tecks2.TextTransparency = tecks2.TextTransparency + 0.04
					tecks3.Rotation = tecks2.Rotation - 0.75
					tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency + 0.04
					tecks3.TextTransparency = tecks2.TextTransparency + 0.04
				end
			end
			naeeym2:Destroy()
		end)
		chat()
	end
	local Create = nil
	CFuncs = {
		Part = {
			Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
				local Part = Create("Part")({
					Parent = Parent,
					Reflectance = Reflectance,
					Transparency = Transparency,
					CanCollide = false,
					Locked = true,
					BrickColor = BrickColor.new(tostring(BColor)),
					Name = Name,
					Size = Size,
					Material = Material
				})
				RemoveOutlines(Part)
				return Part
			end
		},
		Mesh = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh)({
					Parent = Part,
					Offset = OffSet,
					Scale = Scale
				})
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end
		},
		Mesh = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh)({
					Parent = Part,
					Offset = OffSet,
					Scale = Scale
				})
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end
		},
		Weld = {
			Create = function(Parent, Part0, Part1, C0, C1)
				local Weld = Create("Weld")({
					Parent = Parent,
					Part0 = Part0,
					Part1 = Part1,
					C0 = C0,
					C1 = C1
				})
				return Weld
			end
		},
		Sound = {
			Create = function(id, par, vol, pit)
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound")({
						Volume = vol,
						Pitch = pit or 1,
						SoundId = id,
						Parent = par or workspace
					})
					wait()
					S:play()
					game:GetService("Debris"):AddItem(S, 10)
				end))
			end
		},
		LongSound = {
			Create = function(id, par, vol, pit)
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound")({
						Volume = vol,
						Pitch = pit or 1,
						SoundId = id,
						Parent = par or workspace
					})
					wait()
					S:play()
					game:GetService("Debris"):AddItem(S, 30)
				end))
			end
		},
		ParticleEmitter = {
			Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
				local fp = Create("ParticleEmitter")({
					Parent = Parent,
					Color = ColorSequence.new(Color1, Color2),
					LightEmission = LightEmission,
					Size = Size,
					Texture = Texture,
					Transparency = Transparency,
					ZOffset = ZOffset,
					Acceleration = Accel,
					Drag = Drag,
					LockedToPart = LockedToPart,
					VelocityInheritance = VelocityInheritance,
					EmissionDirection = EmissionDirection,
					Enabled = Enabled,
					Lifetime = LifeTime,
					Rate = Rate,
					Rotation = Rotation,
					RotSpeed = RotSpeed,
					Speed = Speed,
					VelocitySpread = VelocitySpread
				})
				return fp
			end
		},
		CreateTemplate = {}
	}
	function New(Object, Parent, Name, Data)
		local Object = Instance.new(Object)
		for Index, Value in pairs(Data or {}) do
			Object[Index] = Value
		end
		Object.Parent = Parent
		Object.Name = Name
		return Object
	end
	local halocolor = BrickColor.new("Pastel light blue")
	local halocolor2 = BrickColor.new("Really black")
	local starcolor = BrickColor.new("Really black")
	local lunacolor = BrickColor.new("Navy blue")
	local lunacolor2 = BrickColor.new("Bright blue")
	local wepcolor = BrickColor.new("Really black")
	local maincolor = BrickColor.new("Really black")
	local m = Instance.new("Model", char)
	local m2 = Instance.new("Model", char)
	local m3 = Instance.new("Model", char)
	local mw1 = Instance.new("Model", char)
	local mw2 = Instance.new("Model", char)
	local extrawingmod1 = Instance.new("Model", char)
	local extrawingmod2 = Instance.new("Model", char)
	function CreateParta(parent, transparency, reflectance, material, brickcolor)
		local p = Instance.new("Part")
		p.TopSurface = 0
		p.BottomSurface = 0
		p.Parent = parent
		p.Size = Vector3.new(0.1, 0.1, 0.1)
		p.Transparency = transparency
		p.Reflectance = reflectance
		p.CanCollide = false
		p.Locked = true
		p.BrickColor = brickcolor
		p.Material = material
		return p
	end
	function CreateMesh(parent, meshtype, x1, y1, z1)
		local mesh = Instance.new("SpecialMesh", parent)
		mesh.MeshType = meshtype
		mesh.Scale = Vector3.new(x1 * 10, y1 * 10, z1 * 10)
		return mesh
	end
	function CreateSpecialMesh(parent, meshid, x1, y1, z1)
		local mesh = Instance.new("SpecialMesh", parent)
		mesh.MeshType = "FileMesh"
		mesh.MeshId = meshid
		mesh.Scale = Vector3.new(x1, y1, z1)
		return mesh
	end
	function CreateSpecialGlowMesh(parent, meshid, x1, y1, z1)
		local mesh = Instance.new("SpecialMesh", parent)
		mesh.MeshType = "FileMesh"
		mesh.MeshId = meshid
		mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
		mesh.Scale = Vector3.new(x1, y1, z1)
		mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
		return mesh
	end
	function CreateWeld(parent, part0, part1, C1X, C1Y, C1Z, C1Xa, C1Ya, C1Za, C0X, C0Y, C0Z, C0Xa, C0Ya, C0Za)
		local weld = Instance.new("Weld")
		weld.Parent = parent
		weld.Part0 = part0
		weld.Part1 = part1
		weld.C1 = CFrame.new(C1X, C1Y, C1Z) * CFrame.Angles(C1Xa, C1Ya, C1Za)
		weld.C0 = CFrame.new(C0X, C0Y, C0Z) * CFrame.Angles(C0Xa, C0Ya, C0Za)
		return weld
	end
	local handlex = CreateParta(mw2, 1, 1, "Neon", maincolor)
	CreateMesh(handle, "Brick", 0, 0, 0)
	local handlexweld = CreateWeld(handlex, tors, handlex, 0, -1.5, -1.05, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	local valuaring = 10
	for i = 0, 49 do
		valuaring = valuaring + 10
		rn = CreateParta(mw2, 0, 0, "Neon", halocolor)
		CreateMesh(rn, "Brick", 0.25, 0.1, 0.1)
		CreateWeld(rn, handlex, rn, 0, 1, 0, math.rad(0), math.rad(0), math.rad(valuaring), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	end
	local handle = CreateParta(m, 1, 1, "Neon", maincolor)
	CreateMesh(handle, "Brick", 0.5, 0.5, 0.5)
	local handleweld = CreateWeld(handle, tors, handle, 0, -1.5, -1.05, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	local lwing1 = CreateParta(m, 1, 1, "Neon", maincolor)
	CreateMesh(handle, "Brick", 0.5, 0.5, 0.5)
	local lwing1weld = CreateWeld(lwing1, handle, lwing1, 3, 0, 0, math.rad(5), math.rad(0), math.rad(12.5), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, lwing1, wed, 0, 0, 0.25, math.rad(0), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, lwing1, wed, 0, 0, 0.25, math.rad(0), math.rad(-90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 3)
	CreateWeld(wed, lwing1, wed, 0, -0.25, 1.75, math.rad(0), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 3, 0.5)
	CreateWeld(wed, lwing1, wed, 0, -1.75, 0.25, math.rad(90), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	local lwing2 = CreateParta(m, 1, 1, "Neon", maincolor)
	CreateMesh(handle, "Brick", 0.5, 0.5, 0.5)
	local lwing2weld = CreateWeld(lwing2, handle, lwing2, 4, 1, 0, math.rad(10), math.rad(0), math.rad(25), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, lwing2, wed, 0, 0, 0.25, math.rad(0), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, lwing2, wed, 0, 0, 0.25, math.rad(0), math.rad(-90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 3)
	CreateWeld(wed, lwing2, wed, 0, -0.25, 1.75, math.rad(0), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 3, 0.5)
	CreateWeld(wed, lwing2, wed, 0, -1.75, 0.25, math.rad(90), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	local lwing3 = CreateParta(m, 1, 1, "Neon", maincolor)
	CreateMesh(handle, "Brick", 0.5, 0.5, 0.5)
	local lwing3weld = CreateWeld(lwing3, handle, lwing3, 4.75, 2, 0, math.rad(15), math.rad(0), math.rad(37.5), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, lwing3, wed, 0, 0, 0.25, math.rad(0), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, lwing3, wed, 0, 0, 0.25, math.rad(0), math.rad(-90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 3)
	CreateWeld(wed, lwing3, wed, 0, -0.25, 1.75, math.rad(0), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 3, 0.5)
	CreateWeld(wed, lwing3, wed, 0, -1.75, 0.25, math.rad(90), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	local lwing4 = CreateParta(m, 1, 1, "Neon", maincolor)
	CreateMesh(handle, "Brick", 0.5, 0.5, 0.5)
	local lwing4weld = CreateWeld(lwing4, handle, lwing4, 5.75, 3, 0, math.rad(20), math.rad(0), math.rad(50), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, lwing4, wed, 0, 0, 0.25, math.rad(0), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, lwing4, wed, 0, 0, 0.25, math.rad(0), math.rad(-90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 3)
	CreateWeld(wed, lwing4, wed, 0, -0.25, 1.75, math.rad(0), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 3, 0.5)
	CreateWeld(wed, lwing4, wed, 0, -1.75, 0.25, math.rad(90), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	local lwing5 = CreateParta(m, 1, 1, "Neon", maincolor)
	CreateMesh(handle, "Brick", 0.5, 0.5, 0.5)
	local lwing5weld = CreateWeld(lwing5, handle, lwing5, 6.75, 4, 0, math.rad(25), math.rad(0), math.rad(62.5), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, lwing5, wed, 0, 0, 0.25, math.rad(0), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, lwing5, wed, 0, 0, 0.25, math.rad(0), math.rad(-90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 3)
	CreateWeld(wed, lwing5, wed, 0, -0.25, 1.75, math.rad(0), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 3, 0.5)
	CreateWeld(wed, lwing5, wed, 0, -1.75, 0.25, math.rad(90), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	local lwing6 = CreateParta(m, 1, 1, "Neon", maincolor)
	CreateMesh(handle, "Brick", 0.5, 0.5, 0.5)
	local lwing6weld = CreateWeld(lwing6, handle, lwing6, 7.75, 5, 0, math.rad(30), math.rad(0), math.rad(75), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, lwing6, wed, 0, 0, 0.25, math.rad(0), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, lwing6, wed, 0, 0, 0.25, math.rad(0), math.rad(-90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 3)
	CreateWeld(wed, lwing6, wed, 0, -0.25, 1.75, math.rad(0), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod1, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 3, 0.5)
	CreateWeld(wed, lwing6, wed, 0, -1.75, 0.25, math.rad(90), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	local rwing1 = CreateParta(m, 1, 1, "Neon", maincolor)
	CreateMesh(handle, "Brick", 0.5, 0.5, 0.5)
	local rwing1weld = CreateWeld(rwing1, handle, rwing1, -3, 0, 0, math.rad(5), math.rad(0), math.rad(-12.5), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, rwing1, wed, 0, 0, 0.25, math.rad(0), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, rwing1, wed, 0, 0, 0.25, math.rad(0), math.rad(-90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 3)
	CreateWeld(wed, rwing1, wed, 0, -0.25, 1.75, math.rad(0), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 3, 0.5)
	CreateWeld(wed, rwing1, wed, 0, -1.75, 0.25, math.rad(90), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	local rwing2 = CreateParta(m, 1, 1, "Neon", maincolor)
	CreateMesh(handle, "Brick", 0.5, 0.5, 0.5)
	local rwing2weld = CreateWeld(rwing2, handle, rwing2, -4, 1, 0, math.rad(10), math.rad(0), math.rad(-25), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, rwing2, wed, 0, 0, 0.25, math.rad(0), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, rwing2, wed, 0, 0, 0.25, math.rad(0), math.rad(-90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 3)
	CreateWeld(wed, rwing2, wed, 0, -0.25, 1.75, math.rad(0), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 3, 0.5)
	CreateWeld(wed, rwing2, wed, 0, -1.75, 0.25, math.rad(90), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	local rwing3 = CreateParta(m, 1, 1, "Neon", maincolor)
	CreateMesh(handle, "Brick", 0.5, 0.5, 0.5)
	local rwing3weld = CreateWeld(rwing3, handle, rwing3, -4.75, 2, 0, math.rad(15), math.rad(0), math.rad(-37.5), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, rwing3, wed, 0, 0, 0.25, math.rad(0), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, rwing3, wed, 0, 0, 0.25, math.rad(0), math.rad(-90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 3)
	CreateWeld(wed, rwing3, wed, 0, -0.25, 1.75, math.rad(0), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(mw2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 3, 0.5)
	CreateWeld(wed, rwing3, wed, 0, -1.75, 0.25, math.rad(90), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	local rwing4 = CreateParta(m, 1, 1, "Neon", maincolor)
	CreateMesh(handle, "Brick", 0.5, 0.5, 0.5)
	local rwing4weld = CreateWeld(rwing4, handle, rwing4, -5.75, 3, 0, math.rad(20), math.rad(0), math.rad(-50), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, rwing4, wed, 0, 0, 0.25, math.rad(0), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, rwing4, wed, 0, 0, 0.25, math.rad(0), math.rad(-90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 3)
	CreateWeld(wed, rwing4, wed, 0, -0.25, 1.75, math.rad(0), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 3, 0.5)
	CreateWeld(wed, rwing4, wed, 0, -1.75, 0.25, math.rad(90), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	local rwing5 = CreateParta(m, 1, 1, "Neon", maincolor)
	CreateMesh(handle, "Brick", 0.5, 0.5, 0.5)
	local rwing5weld = CreateWeld(rwing5, handle, rwing5, -6.75, 4, 0, math.rad(25), math.rad(0), math.rad(-62.5), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, rwing5, wed, 0, 0, 0.25, math.rad(0), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, rwing5, wed, 0, 0, 0.25, math.rad(0), math.rad(-90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 3)
	CreateWeld(wed, rwing5, wed, 0, -0.25, 1.75, math.rad(0), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 3, 0.5)
	CreateWeld(wed, rwing5, wed, 0, -1.75, 0.25, math.rad(90), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	local rwing6 = CreateParta(m, 1, 1, "Neon", maincolor)
	CreateMesh(handle, "Brick", 0.5, 0.5, 0.5)
	local rwing6weld = CreateWeld(rwing6, handle, rwing6, -7.75, 3, 0, math.rad(30), math.rad(0), math.rad(-75), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, rwing6, wed, 0, 0, 0.25, math.rad(0), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 0.5)
	CreateWeld(wed, rwing6, wed, 0, 0, 0.25, math.rad(0), math.rad(-90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 0.5, 3)
	CreateWeld(wed, rwing6, wed, 0, -0.25, 1.75, math.rad(0), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	wed = CreateParta(extrawingmod2, 0, 0, "Neon", halocolor)
	CreateMesh(wed, "Wedge", 0.05, 3, 0.5)
	CreateWeld(wed, rwing6, wed, 0, -1.75, 0.25, math.rad(90), math.rad(90), math.rad(90), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	ran = CreateParta(m2, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(ran, "Wedge", 1.02, 1.02, 1.02)
	CreateWeld(ran, larm, ran, 0, 0.15, 0, math.rad(0), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	ran = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(ran, "Wedge", 0.9, 0.9, 1.025)
	CreateWeld(ran, larm, ran, 0, 0.155, 0, math.rad(0), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	ran = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(ran, "Wedge", 1.025, 0.9, 0.9)
	CreateWeld(ran, larm, ran, 0, 0.155, -0.025, math.rad(0), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	gan = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(gan, "Brick", 1.075, 0.1, 1.075)
	CreateWeld(gan, larm, gan, 0, 0.5, 0, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	gan = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(gan, "Brick", 1.075, 0.1, 1.075)
	CreateWeld(gan, larm, gan, 0, 0.75, 0, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	gan = CreateParta(m2, 0, 0, "Neon", halocolor2)
	CreateMesh(gan, "Brick", 1.095, 0.035, 1.095)
	CreateWeld(gan, larm, gan, 0, 0.5, 0, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	gan = CreateParta(m2, 0, 0, "Neon", halocolor2)
	CreateMesh(gan, "Brick", 1.095, 0.035, 1.095)
	CreateWeld(gan, larm, gan, 0, 0.75, 0, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	gane = CreateParta(m3, 0, 0, "SmoothPlastic", lunacolor2)
	CreateMesh(gane, "Brick", 1.0625, 0.2, 1.0625)
	CreateWeld(gane, larm, gane, 0, 0.6, 0, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	star = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateSpecialMesh(star, "http://www.roblox.com/asset/?id=45428961", 2.5, 2.5, 2.5)
	CreateWeld(star, larm, star, 0, 0.475, 0.6, math.rad(90), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	starl = CreateParta(m3, 0, 0, "SmoothPlastic", starcolor)
	CreateSpecialMesh(starl, "http://www.roblox.com/asset/?id=45428961", 1.95, 2.55, 1.95)
	CreateWeld(starl, larm, starl, 0, 0.475, 0.6, math.rad(90), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, larm, dotsec, 0, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, larm, dotseca, 0, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, larm, dotsecb, 0, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, larm, dotsec, 0.2, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, larm, dotseca, 0.2, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, larm, dotsecb, 0.2, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, larm, dotsec, 0.4, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, larm, dotseca, 0.4, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, larm, dotsecb, 0.4, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, larm, dotsec, -0.2, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, larm, dotseca, -0.2, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, larm, dotsecb, -0.2, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, larm, dotsec, -0.4, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, larm, dotseca, -0.4, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, larm, dotsecb, -0.4, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, larm, dotsec, 0, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, larm, dotseca, 0, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, larm, dotsecb, 0, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, larm, dotsec, 0.2, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, larm, dotseca, 0.2, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, larm, dotsecb, 0.2, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, larm, dotsec, 0.4, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, larm, dotseca, 0.4, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, larm, dotsecb, 0.4, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, larm, dotsec, -0.2, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, larm, dotseca, -0.2, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, larm, dotsecb, -0.2, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, larm, dotsec, -0.4, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, larm, dotseca, -0.4, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, larm, dotsecb, -0.4, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	ran = CreateParta(m2, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(ran, "Wedge", 1.02, 1.02, 1.02)
	CreateWeld(ran, rarm, ran, 0, 0.15, 0, math.rad(0), math.rad(-90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	ran = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(ran, "Wedge", 0.9, 0.9, 1.025)
	CreateWeld(ran, rarm, ran, 0, 0.155, 0, math.rad(0), math.rad(-90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	ran = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(ran, "Wedge", 1.025, 0.9, 0.9)
	CreateWeld(ran, rarm, ran, 0, 0.155, -0.025, math.rad(0), math.rad(-90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	gan = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(gan, "Brick", 1.075, 0.1, 1.075)
	CreateWeld(gan, rarm, gan, 0, 0.5, 0, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	gan = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(gan, "Brick", 1.075, 0.1, 1.075)
	CreateWeld(gan, rarm, gan, 0, 0.75, 0, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	gan = CreateParta(m2, 0, 0, "Neon", halocolor2)
	CreateMesh(gan, "Brick", 1.095, 0.035, 1.095)
	CreateWeld(gan, rarm, gan, 0, 0.5, 0, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	gan = CreateParta(m2, 0, 0, "Neon", halocolor2)
	CreateMesh(gan, "Brick", 1.095, 0.035, 1.095)
	CreateWeld(gan, rarm, gan, 0, 0.75, 0, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	gane = CreateParta(m3, 0, 0, "SmoothPlastic", lunacolor2)
	CreateMesh(gane, "Brick", 1.0625, 0.2, 1.0625)
	CreateWeld(gane, rarm, gane, 0, 0.6, 0, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	star = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateSpecialMesh(star, "http://www.roblox.com/asset/?id=45428961", 2.5, 2.5, 2.5)
	CreateWeld(star, rarm, star, 0, -0.475, 0.6, math.rad(90), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	starl = CreateParta(m3, 0, 0, "SmoothPlastic", starcolor)
	CreateSpecialMesh(starl, "http://www.roblox.com/asset/?id=45428961", 1.95, 2.55, 1.95)
	CreateWeld(starl, rarm, starl, 0, -0.475, 0.6, math.rad(90), math.rad(90), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, rarm, dotsec, 0, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, rarm, dotseca, 0, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, rarm, dotsecb, 0, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, rarm, dotsec, 0.2, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, rarm, dotseca, 0.2, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, rarm, dotsecb, 0.2, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, rarm, dotsec, 0.4, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, rarm, dotseca, 0.4, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, rarm, dotsecb, 0.4, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, rarm, dotsec, -0.2, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, rarm, dotseca, -0.2, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, rarm, dotsecb, -0.2, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, rarm, dotsec, -0.4, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, rarm, dotseca, -0.4, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, rarm, dotsecb, -0.4, 0.635, -0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, rarm, dotsec, 0, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, rarm, dotseca, 0, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, rarm, dotsecb, 0, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, rarm, dotsec, 0.2, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, rarm, dotseca, 0.2, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, rarm, dotsecb, 0.2, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, rarm, dotsec, 0.4, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, rarm, dotseca, 0.4, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, rarm, dotsecb, 0.4, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, rarm, dotsec, -0.2, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, rarm, dotseca, -0.2, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, rarm, dotsecb, -0.2, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsec = CreateParta(m3, 0, 0, "Neon", halocolor)
	CreateMesh(dotsec, "Sphere", 0.1, 0.1, 0.15)
	CreateWeld(dotsec, rarm, dotsec, -0.4, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotseca = CreateParta(m, 0, 0, "SmoothPlastic", wepcolor)
	CreateMesh(dotseca, "Sphere", 0.2, 0.2, 0.1)
	CreateWeld(dotseca, rarm, dotseca, -0.4, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	dotsecb = CreateParta(m2, 0, 0, "SmoothPlastic", lunacolor)
	CreateMesh(dotsecb, "Sphere", 0.15, 0.15, 0.125)
	CreateWeld(dotsecb, rarm, dotsecb, -0.4, 0.635, 0.5, math.rad(0), math.rad(0), math.rad(0), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	for i, v in pairs(m:GetChildren()) do
		if v:IsA("Part") then
			v.BrickColor = BrickColor.new("Really black")
			v.Material = "Glass"
		end
	end
	for i, v in pairs(m2:GetChildren()) do
		if v:IsA("Part") then
			v.BrickColor = BrickColor.new("Crimson")
			v.Material = "Granite"
		end
	end
	for i, v in pairs(m3:GetChildren()) do
		if v:IsA("Part") then
			v.BrickColor = BrickColor.new("Really red")
			v.Material = "Neon"
		end
	end
	for i, v in pairs(mw2:GetChildren()) do
		if v:IsA("Part") then
			v.BrickColor = BrickColor.new("Really red")
			v.Material = "Neon"
		end
	end
	for i, v in pairs(mw1:GetChildren()) do
		if v:IsA("Part") then
			v.Transparency = 1
			v.BrickColor = BrickColor.new("Really red")
			v.Material = "Neon"
		end
	end
	for i, v in pairs(extrawingmod1:GetChildren()) do
		if v:IsA("Part") then
			v.Transparency = 1
			v.BrickColor = BrickColor.new("White")
			v.Material = "Neon"
		end
	end
	for i, v in pairs(extrawingmod2:GetChildren()) do
		if v:IsA("Part") then
			v.Transparency = 1
			v.BrickColor = BrickColor.new("White")
			v.Material = "Neon"
		end
	end

	FHead = New("Part",char,"FHead",{CanCollide = false,BrickColor = BrickColor.new("Really black"),Size = Vector3.new(1.20000005, 0.600000024, 1),CFrame = CFrame.new(68.5999985, 0.700013041, 9.89999962, 1, 0, 0, 0, 1, 0, 0, 0, 1),Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
	Mesh = New("SpecialMesh",FHead,"Mesh",{Scale = Vector3.new(1.25999999, 1.5, 1.25999999),})
	Weld = New("Weld",FHead,"mot",{Part0 = FHead,Part1 = char.Head,C1 = CFrame.new(0, 0.200000048, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),})
	FHead.CanCollide = false



	local MAINRUINCOLOR = BrickColor.new("Really red")
	function RemoveOutlines(part)
		part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
	end
	function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
		local Part = Create("Part")({
			Parent = Parent,
			Reflectance = Reflectance,
			Transparency = Transparency,
			CanCollide = false,
			Locked = true,
			BrickColor = BrickColor.new(tostring(BColor)),
			Name = Name,
			Size = Size,
			Material = Material
		})
		Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
		RemoveOutlines(Part)
		return Part
	end
	function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
		local Msh = Create(Mesh)({
			Parent = Part,
			Offset = OffSet,
			Scale = Scale
		})
		if Mesh == "SpecialMesh" then
			Msh.MeshType = MeshType
			Msh.MeshId = MeshId
		end
		return Msh
	end
	function CreateWeld(Parent, Part0, Part1, C0, C1)
		local Weld = Create("Weld")({
			Parent = Parent,
			Part0 = Part0,
			Part1 = Part1,
			C0 = C0,
			C1 = C1
		})
		return Weld
	end
	Player = game:GetService("Players").LocalPlayer
	Character = FakeCharacter
	PlayerGui = Player.PlayerGui
	Backpack = Player.Backpack
	Torso = Character.Torso
	Head = Character.Head
	Humanoid = Character.Humanoid
	m = Instance.new("Model", Character)
	LeftArm = Character["Left Arm"]
	LeftLeg = Character["Left Leg"]
	RightArm = Character["Right Arm"]
	RightLeg = Character["Right Leg"]
	LS = Torso["Left Shoulder"]
	LH = Torso["Left Hip"]
	RS = Torso["Right Shoulder"]
	RH = Torso["Right Hip"]
	Face = Head.face
	Neck = Torso.Neck
	it = Instance.new
	attacktype = 1
	vt = Vector3.new
	cf = CFrame.new
	euler = CFrame.fromEulerAnglesXYZ
	angles = CFrame.Angles
	cloaked = false
	necko = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
	necko2 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
	LHC0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
	LHC1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
	RHC0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
	RHC1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
	RootPart = Character.HumanoidRootPart
	RootJoint = RootPart.RootJoint
	RootCF = euler(-1.57, 0, 3.14)
	attack = false
	attackdebounce = false
	deb = false
	equipped = true
	hand = false
	MMouse = nil
	combo = 0
	mana = 0
	trispeed = 0.2
	attackmode = "none"
	local idle = 0
	local Anim = "Idle"
	local Effects = {}
	local gun = false
	local shoot = false
	local sine = 0
	local change = 1
	player = nil
	local toggleTag = true
	local txt = Instance.new("BillboardGui", Head)
	txt.Adornee = nil
	txt.Name = "NameDetect"
	txt.Size = UDim2.new(4, 0, 1.2, 0)
	txt.StudsOffset = Vector3.new(-8, 5.333333333333333, 0)
	local text = Instance.new("TextLabel", txt)
	text.Size = UDim2.new(5, 0, 3.5, 0)
	text.FontSize = "Size8"
	text.TextScaled = true
	text.TextTransparency = 0
	text.BackgroundTransparency = 1
	text.TextTransparency = 0
	text.TextStrokeTransparency = 0
	text.Font = "Fantasy"
	text.TextStrokeColor3 = Color3.new(1, 0, 0)
	text.TextColor3 = Color3.new(0, 0, 0)
	text.Text = "Sweet Dreams"
	function RecolorTextAndRename(name, col1, col2)
		text.TextStrokeColor3 = col2
		text.TextColor3 = col1
		text.Text = name
	end
	mouse = Player:GetMouse()
	RSH, LSH = nil, nil
	RW, LW = Instance.new("Weld"), Instance.new("Weld")
	RW.Name = "Right Shoulder"
	LW.Name = "Left Shoulder"
	LH = Torso["Left Hip"]
	RH = Torso["Right Hip"]
	TorsoColor = Torso.BrickColor
	function NoOutline(Part)
		Part.TopSurface, Part.BottomSurface, Part.LeftSurface, Part.RightSurface, Part.FrontSurface, Part.BackSurface = 10, 10, 10, 10, 10, 10
	end
	player = Player
	ch = Character
	RSH = ch.Torso["Right Shoulder"]
	LSH = ch.Torso["Left Shoulder"]
	RSH.Parent = nil
	LSH.Parent = nil
	RW.Name = "Right Shoulder"
	RW.Part0 = ch.Torso
	RW.C0 = cf(1.5, 0.5, 0)
	RW.C1 = cf(0, 0.5, 0)
	RW.Part1 = ch["Right Arm"]
	RW.Parent = ch.Torso
	LW.Name = "Left Shoulder"
	LW.Part0 = ch.Torso
	LW.C0 = cf(-1.5, 0.5, 0)
	LW.C1 = cf(0, 0.5, 0)
	LW.Part1 = ch["Left Arm"]
	LW.Parent = ch.Torso
	local Stats = Instance.new("BoolValue")
	Stats.Name = "Stats"
	Stats.Parent = Character
	local Atk = Instance.new("NumberValue")
	Atk.Name = "Damage"
	Atk.Parent = Stats
	Atk.Value = 1
	local Def = Instance.new("NumberValue")
	Def.Name = "Defense"
	Def.Parent = Stats
	Def.Value = 1
	local Speed = Instance.new("NumberValue")
	Speed.Name = "Speed"
	Speed.Parent = Stats
	Speed.Value = 1
	local Mvmt = Instance.new("NumberValue")
	Mvmt.Name = "Movement"
	Mvmt.Parent = Stats
	Mvmt.Value = 1
	local donum = 0
	function part(formfactor, parent, reflectance, transparency, brickcolor, name, size)
		local fp = it("Part")
		fp.formFactor = formfactor
		fp.Parent = parent
		fp.Reflectance = reflectance
		fp.Transparency = transparency
		fp.CanCollide = false
		fp.Locked = true
		fp.BrickColor = brickcolor
		fp.Name = name
		fp.Size = size
		fp.Position = Torso.Position
		NoOutline(fp)
		fp.Material = "SmoothPlastic"
		fp:BreakJoints()
		return fp
	end
	function mesh(Mesh, part, meshtype, meshid, offset, scale)
		local mesh = it(Mesh)
		mesh.Parent = part
		if Mesh == "SpecialMesh" then
			mesh.MeshType = meshtype
			if meshid ~= "nil" then
				mesh.MeshId = "http://www.roblox.com/asset/?id=" .. meshid
			end
		end
		mesh.Offset = offset
		mesh.Scale = scale
		return mesh
	end
	function weld(parent, part0, part1, c0)
		local weld = it("Weld")
		weld.Parent = parent
		weld.Part0 = part0
		weld.Part1 = part1
		weld.C0 = c0
		return weld
	end
	local Color1 = Torso.BrickColor
	local bodvel = Instance.new("BodyVelocity")
	local bg = Instance.new("BodyGyro")
	function swait(num)
		if num == 0 or num == nil then
			game:service("RunService").Stepped:wait(0)
		else
			for i = 0, num do
				game:service("RunService").Stepped:wait(0)
			end
		end
	end
	local r = 255
	local g = 0
	local b = 0
	coroutine.resume(coroutine.create(function()
		while wait() do
			for i = 0, 50.8 do
				swait()
				g = g + 5
			end
			for i = 0, 50.8 do
				swait()
				r = r - 5
			end
			for i = 0, 50.8 do
				swait()
				b = b + 5
			end
			for i = 0, 50.8 do
				swait()
				g = g - 5
			end
			for i = 0, 50.8 do
				swait()
				r = r + 5
			end
			for i = 0, 50.8 do
				swait()
				b = b - 5
			end
		end
	end))
	function so(id, par, vol, pit)
		coroutine.resume(coroutine.create(function()
			local sou = Instance.new("Sound", par or workspace)
			sou.Volume = vol
			sou.Pitch = pit or 1
			sou.SoundId = id
			swait()
			sou:play()
			game:GetService("Debris"):AddItem(sou, 6)
		end))
	end
	function clerp(a, b, t)
		local qa = {
			QuaternionFromCFrame(a)
		}
		local qb = {
			QuaternionFromCFrame(b)
		}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1 - t
		return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
	end
	function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then
			local s = math.sqrt(1 + trace)
			local recip = 0.5 / s
			return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
		else
			local i = 0
			if m00 < m11 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then
				i = 2
			end
			if i == 0 then
				local s = math.sqrt(m00 - m11 - m22 + 1)
				local recip = 0.5 / s
				return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
			elseif i == 1 then
				local s = math.sqrt(m11 - m22 - m00 + 1)
				local recip = 0.5 / s
				return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
			elseif i == 2 then
				local s = math.sqrt(m22 - m00 - m11 + 1)
				local recip = 0.5 / s
				return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
			end
		end
	end
	function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w * xs, w * ys, w * zs
		local xx = x * xs
		local xy = x * ys
		local xz = x * zs
		local yy = y * ys
		local yz = y * zs
		local zz = z * zs
		return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
	end
	function QuaternionSlerp(a, b, t)
		local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
		local startInterp, finishInterp
		if cosTheta >= 1.0E-4 then
			if 1 - cosTheta > 1.0E-4 then
				local theta = math.acos(cosTheta)
				local invSinTheta = 1 / math.sin(theta)
				startInterp = math.sin((1 - t) * theta) * invSinTheta
				finishInterp = math.sin(t * theta) * invSinTheta
			else
				startInterp = 1 - t
				finishInterp = t
			end
		elseif 1 + cosTheta > 1.0E-4 then
			local theta = math.acos(-cosTheta)
			local invSinTheta = 1 / math.sin(theta)
			startInterp = math.sin((t - 1) * theta) * invSinTheta
			finishInterp = math.sin(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
		return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
	end
	local CFrameFromTopBack = function(at, top, back)
		local right = top:Cross(back)
		return CFrame.new(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
	end
	function Triangle(a, b, c)
		local edg1 = (c - a):Dot((b - a).unit)
		local edg2 = (a - b):Dot((c - b).unit)
		local edg3 = (b - c):Dot((a - c).unit)
		if edg1 <= (b - a).magnitude and edg1 >= 0 then
			a, b = a, b
		elseif edg2 <= (c - b).magnitude and edg2 >= 0 then
			a, b, c = b, c, a
		elseif edg3 <= (a - c).magnitude and edg3 >= 0 then
			a, b, c = c, a, b
		else
			assert(false, "unreachable")
		end
		local len1 = (c - a):Dot((b - a).unit)
		local len2 = (b - a).magnitude - len1
		local width = (a + (b - a).unit * len1 - c).magnitude
		local maincf = CFrameFromTopBack(a, (b - a):Cross(c - b).unit, -(b - a).unit)
		local list = {}
		if len1 > 0.01 then
			local w1 = Instance.new("WedgePart", m)
			game:GetService("Debris"):AddItem(w1, 5)
			w1.Material = "SmoothPlastic"
			w1.FormFactor = "Custom"
			w1.BrickColor = BrickColor.new("Really red")
			w1.Transparency = 0
			w1.Reflectance = 0
			w1.Material = "SmoothPlastic"
			w1.CanCollide = false
			local l1 = Instance.new("PointLight", w1)
			l1.Color = Color3.new(170, 0, 0)
			NoOutline(w1)
			local sz = Vector3.new(0.2, width, len1)
			w1.Size = sz
			local sp = Instance.new("SpecialMesh", w1)
			sp.MeshType = "Wedge"
			sp.Scale = Vector3.new(0, 1, 1) * sz / w1.Size
			w1:BreakJoints()
			w1.Anchored = true
			w1.Parent = workspace
			w1.Transparency = 0.7
			table.insert(Effects, {
				w1,
				"Disappear",
				0.01
			})
			w1.CFrame = maincf * CFrame.Angles(math.pi, 0, math.pi / 2) * CFrame.new(0, width / 2, len1 / 2)
			table.insert(list, w1)
		end
		if len2 > 0.01 then
			local w2 = Instance.new("WedgePart", m)
			game:GetService("Debris"):AddItem(w2, 5)
			w2.Material = "SmoothPlastic"
			w2.FormFactor = "Custom"
			w2.BrickColor = BrickColor.new("Really red")
			w2.Transparency = 0
			w2.Reflectance = 0
			w2.Material = "SmoothPlastic"
			w2.CanCollide = false
			local l2 = Instance.new("PointLight", w2)
			l2.Color = Color3.new(170, 0, 0)
			NoOutline(w2)
			local sz = Vector3.new(0.2, width, len2)
			w2.Size = sz
			local sp = Instance.new("SpecialMesh", w2)
			sp.MeshType = "Wedge"
			sp.Scale = Vector3.new(0, 1, 1) * sz / w2.Size
			w2:BreakJoints()
			w2.Anchored = true
			w2.Parent = workspace
			w2.Transparency = 0.7
			table.insert(Effects, {
				w2,
				"Disappear",
				0.01
			})
			w2.CFrame = maincf * CFrame.Angles(math.pi, math.pi, -math.pi / 2) * CFrame.new(0, width / 2, -len1 - len2 / 2)
			table.insert(list, w2)
		end
		return unpack(list)
	end
	function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
		if hit.Parent == nil then
			return
		end
		local h = hit.Parent:FindFirstChildOfClass("Humanoid")
		for _, v in pairs(hit.Parent:children()) do
			if v:IsA("Humanoid") then
				h = v
			end
		end
		if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Head") ~= nil then
			if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
				return
			end
			local c = Create("ObjectValue")({
				Name = "creator",
				Value = game:service("Players").LocalPlayer,
				Parent = h
			})
			game:GetService("Debris"):AddItem(c, 0.5)
			if HitSound ~= nil and HitPitch ~= nil then
				CFuncs.Sound.Create(HitSound, hit, 1, HitPitch)
			end
			local Damage = math.random(minim, maxim)
			local blocked = false
			local block = hit.Parent:findFirstChild("Block")
			if block ~= nil and block.className == "IntValue" and block.Value > 0 then
				blocked = true
				block.Value = block.Value - 1
				print(block.Value)
			end
			if blocked == false then
				HitHealth = h.Health
				h.Health = h.Health - Damage
				if HitHealth ~= h.Health and HitHealth ~= 0 and 0 >= h.Health and h.Parent.Name ~= "Hologram" then
					print("gained kill")
				end
				ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
			else
				h.Health = h.Health - Damage / 2
				ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
			end
			if Type == "Knockdown" then
				local hum = hit.Parent.Humanoid
				hum.PlatformStand = true
				coroutine.resume(coroutine.create(function(HHumanoid)
					swait(1)
					HHumanoid.PlatformStand = false
				end), hum)
				local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
				local bodvol = Create("BodyVelocity")({
					velocity = angle * knockback,
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				local rl = Create("BodyAngularVelocity")({
					P = 3000,
					maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
					angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodvol, 0.5)
				game:GetService("Debris"):AddItem(rl, 0.5)
			elseif Type == "Normal" then
				local vp = Create("BodyVelocity")({
					P = 500,
					maxForce = Vector3.new(math.huge, 0, math.huge),
					velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
				})
				if knockback > 0 then
					vp.Parent = hit.Parent.Head
				end
				game:GetService("Debris"):AddItem(vp, 0.5)
			elseif Type == "Up" then
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 1)
			elseif Type == "Leech" then
				local hum = hit.Parent.Humanoid
				if hum ~= nil then
					for i = 0, 2 do
						Effects.Sphere.Create(BrickColor.new("Bright red"), hit.Parent.Torso.CFrame * cn(0, 0, 0) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
					end
					Humanoid.Health = Humanoid.Health + 10
				end
			elseif Type == "UpKnock" then
				local hum = hit.Parent.Humanoid
				hum.PlatformStand = true
				if hum ~= nil then
					hitr = true
				end
				coroutine.resume(coroutine.create(function(HHumanoid)
					swait(5)
					HHumanoid.PlatformStand = false
					hitr = false
				end), hum)
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
				local bodyVelocity = Create("BodyVelocity")({
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8000, 8000, 8000),
					Parent = hit
				})
				game:GetService("Debris"):AddItem(bodyVelocity, 1)
			elseif Type == "Snare" then
				local bp = Create("BodyPosition")({
					P = 2000,
					D = 100,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				game:GetService("Debris"):AddItem(bp, 1)
			elseif Type == "Slashnare" then
				Effects.Block.Create(BrickColor.new("Pastel Blue"), hit.Parent.Torso.CFrame * cn(0, 0, 0), 60, 60, 60, 12, 12, 12, 0.07)
				for i = 1, math.random(4, 5) do
					Effects.Sphere.Create(BrickColor.new("Teal"), hit.Parent.Torso.CFrame * cn(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
				end
				local bp = Create("BodyPosition")({
					P = 2000,
					D = 100,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				game:GetService("Debris"):AddItem(bp, 1)
			elseif Type == "Spike" then
				CreateBigIceSword(hit.Parent.Torso.CFrame)
				local bp = Create("BodyPosition")({
					P = 2000,
					D = 100,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				game:GetService("Debris"):AddItem(bp, 1)
			elseif Type == "Freeze" then
				local BodPos = Create("BodyPosition")({
					P = 50000,
					D = 1000,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso
				})
				local BodGy = Create("BodyGyro")({
					maxTorque = Vector3.new(400000, 400000, 400000) * math.huge,
					P = 20000,
					Parent = hit.Parent.Torso,
					cframe = hit.Parent.Torso.CFrame
				})
				hit.Parent.Torso.Anchored = true
				coroutine.resume(coroutine.create(function(Part)
					swait(1.5)
					Part.Anchored = false
				end), hit.Parent.Torso)
				game:GetService("Debris"):AddItem(BodPos, 3)
				game:GetService("Debris"):AddItem(BodGy, 3)
			end
			local debounce = Create("BoolValue")({
				Name = "DebounceHit",
				Parent = hit.Parent,
				Value = true
			})
			game:GetService("Debris"):AddItem(debounce, Delay)
			c = Instance.new("ObjectValue")
			c.Name = "creator"
			c.Value = Player
			c.Parent = h
			game:GetService("Debris"):AddItem(c, 0.5)
		end
	end
	function ShowDamage(Pos, Text, Time, Color)
		local Rate = 0.03333333333333333
		local Pos = Pos or Vector3.new(0, 0, 0)
		local Text = Text or ""
		local Time = Time or 2
		local Color = Color or Color3.new(1, 0, 1)
		local EffectPart = CreatePart(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
		EffectPart.Anchored = true
		local BillboardGui = Create("BillboardGui")({
			Size = UDim2.new(3, 0, 3, 0),
			Adornee = EffectPart,
			Parent = EffectPart
		})
		local TextLabel = Create("TextLabel")({
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 1, 0),
			Text = Text,
			TextColor3 = Color,
			TextScaled = true,
			Font = Enum.Font.ArialBold,
			Parent = BillboardGui
		})
		game.Debris:AddItem(EffectPart, Time + 0.1)
		EffectPart.Parent = game:GetService("Workspace")
		delay(0, function()
			local Frames = Time / Rate
			for Frame = 1, Frames do
				wait(Rate)
				local Percent = Frame / Frames
				EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
				TextLabel.TextTransparency = Percent
			end
			if EffectPart and EffectPart.Parent then
				EffectPart:Destroy()
			end
		end)
	end
	function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
		for _, c in pairs(workspace:children()) do
			local hum = c:findFirstChildOfClass("Humanoid")
			if hum ~= nil then
				local head = c:findFirstChild("Head")
				if head ~= nil then
					local targ = head.Position - Part.Position
					local mag = targ.magnitude
					if magni >= mag and c.Name ~= Player.Name then
						Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
					end
				end
			end
		end
	end
	function MagniDamageWithEffect(Part, magni, mindam, maxdam, knock, Type)
		for _, c in pairs(workspace:children()) do
			local hum = c:findFirstChild("Humanoid")
			if hum ~= nil then
				local head = c:findFirstChild("Torso")
				if head ~= nil then
					local targ = head.Position - Part.Position
					local mag = targ.magnitude
					if magni >= mag and c.Name ~= Player.Name then
						MagicBlock(BrickColor.new("Pastel light blue"), head.CFrame, 5, 5, 5, 1, 1, 1, 0.05)
						Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
					end
				end
			end
		end
	end
	function rayCast(Pos, Dir, Max, Ignore)
		return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
	end
	function SkullEffect(brickcolor, cframe, x1, y1, z1, delay)
		local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
		prt.Anchored = true
		prt.CFrame = cframe
		local msh = mesh("SpecialMesh", prt, "FileMesh", "http://www.roblox.com/asset/?id=4770583", vt(0, 0, 0), vt(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 2)
		CF = prt.CFrame
		coroutine.resume(coroutine.create(function(Part, Mesh, TehCF)
			for i = 0, 1, 0.2 do
				wait()
				Part.CFrame = CF * cf(0, 0, -0.4)
			end
			for i = 0, 1, delay do
				wait()
				Mesh.Scale = Mesh.Scale
			end
			for i = 0, 1, 0.1 do
				wait()
				Part.Transparency = i
			end
			Part.Parent = nil
		end), prt, msh, CF)
	end
	function MagicBlock(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt = part(3, char, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
		prt.Anchored = true
		prt.Material = "Neon"
		prt.CFrame = cframe
		prt.CFrame = prt.CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
		msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 5)
		coroutine.resume(coroutine.create(function(Part, Mesh)
			for i = 0, 1, delay do
				swait()
				Part.CFrame = Part.CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
				Part.Transparency = i
				Mesh.Scale = Mesh.Scale + vt(x3, y3, z3)
			end
			Part.Parent = nil
		end), prt, msh)
	end
	function MagicBlockSteady(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, rottype)
		local prt = part(3, char, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
		prt.Anchored = true
		prt.Material = "Neon"
		prt.CFrame = cframe
		msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 5)
		coroutine.resume(coroutine.create(function(Part, Mesh)
			local rtype = rottype
			for i = 0, 1, delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame * CFrame.Angles(0, 0, 0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame * CFrame.Angles(0, 0, -0.1)
				end
				Part.Transparency = i
				Mesh.Scale = Mesh.Scale + vt(x3, y3, z3)
			end
			Part.Parent = nil
		end), prt, msh)
	end
	function MagicSphere(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt = part(3, char, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
		prt.Anchored = true
		prt.CFrame = cframe
		prt.CFrame = prt.CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
		msh = mesh("SpecialMesh", prt, "Sphere", "", vt(0, 0, 0), vt(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 5)
		coroutine.resume(coroutine.create(function(Part, Mesh)
			for i = 0, 1, delay do
				wait()
				Part.Transparency = i
				Mesh.Scale = Mesh.Scale + vt(x3, y3, z3)
			end
			Part.Parent = nil
		end), prt, msh)
	end
	function MagicBlockSteady(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, rottype)
		local prt = part(3, char, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
		prt.Anchored = true
		prt.Material = "Neon"
		prt.CFrame = cframe
		msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 5)
		coroutine.resume(coroutine.create(function(Part, Mesh)
			local rtype = rottype
			for i = 0, 1, delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame * CFrame.Angles(0, 0, 0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame * CFrame.Angles(0, 0, -0.1)
				end
				Part.Transparency = i
				Mesh.Scale = Mesh.Scale + vt(x3, y3, z3)
			end
			Part.Parent = nil
		end), prt, msh)
	end
	function MagicShock(brickcolor, cframe, x1, y1, x3, y3, delay, rottype)
		local prt = part(3, char, 1, 1, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
		prt.Anchored = true
		prt.Material = "Neon"
		prt.CFrame = cframe
		local dec = decal(prt.Color, "http://www.roblox.com/asset/?id=874580939", "Front", prt)
		local dec2 = decal(prt.Color, "http://www.roblox.com/asset/?id=874580939", "Front", prt)
		msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, 0.01))
		game:GetService("Debris"):AddItem(prt, 5)
		coroutine.resume(coroutine.create(function(Part, Mesh)
			local rtype = rottype
			for i = 0, 1, delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame * CFrame.Angles(0, 0, 0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame * CFrame.Angles(0, 0, -0.1)
				end
				dec.Transparency = i
				dec2.Transparency = i
				Mesh.Scale = Mesh.Scale + vt(x3, y3, 0)
			end
			Part.Parent = nil
		end), prt, msh)
	end
	function MagicShockAlt(brickcolor, cframe, x1, y1, x3, y3, delay, rottype)
		local prt = part(3, char, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
		prt.Anchored = true
		prt.Material = "Neon"
		prt.CFrame = cframe
		msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, 0.01))
		game:GetService("Debris"):AddItem(prt, 5)
		coroutine.resume(coroutine.create(function(Part, Mesh)
			local rtype = rottype
			for i = 0, 1, delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame * CFrame.Angles(0, 0, 0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame * CFrame.Angles(0, 0, -0.1)
				end
				prt.Transparency = i
				Mesh.Scale = Mesh.Scale + vt(x3, y3, 0)
			end
			Part.Parent = nil
		end), prt, msh)
	end
	function MagicShockAltCircle(brickcolor, cframe, x1, z1, x3, z3, delay, rottype)
		local prt = part(3, char, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
		prt.Anchored = true
		prt.Material = "Neon"
		prt.CFrame = cframe
		msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, 1, z1))
		game:GetService("Debris"):AddItem(prt, 5)
		coroutine.resume(coroutine.create(function(Part, Mesh)
			local rtype = rottype
			for i = 0, 1, delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame * CFrame.Angles(0, 0.1, 0)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame * CFrame.Angles(0, -0.1, 0)
				end
				prt.Transparency = i
				Mesh.Scale = Mesh.Scale + vt(x3, 0, z3)
			end
			Part.Parent = nil
		end), prt, msh)
	end
	function MagicShockTrailAlt(brickcolor, cframe, x1, y1, z1, x3, y3, delay, rottype)
		local prt = part(3, char, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
		prt.Anchored = true
		prt.Material = "Neon"
		prt.CFrame = cframe
		msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 5)
		coroutine.resume(coroutine.create(function(Part, Mesh)
			local rtype = rottype
			for i = 0, 1, delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame * CFrame.Angles(0, 0, 0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame * CFrame.Angles(0, 0, -0.1)
				end
				prt.Transparency = i
				Mesh.Scale = Mesh.Scale + vt(x3, y3, 0)
			end
			Part.Parent = nil
		end), prt, msh)
	end
	function MagicShockTrailAlt2(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, rottype)
		local prt = part(3, char, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
		prt.Anchored = true
		prt.Material = "Neon"
		prt.CFrame = cframe
		msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 5)
		coroutine.resume(coroutine.create(function(Part, Mesh)
			local rtype = rottype
			for i = 0, 1, delay do
				swait()
				if rtype == 1 then
					prt.CFrame = prt.CFrame * CFrame.Angles(0, 0, 0.1)
				elseif rtype == 2 then
					prt.CFrame = prt.CFrame * CFrame.Angles(0, 0, -0.1)
				end
				prt.Transparency = i
				Mesh.Scale = Mesh.Scale + vt(x3, y3, z3)
			end
			Part.Parent = nil
		end), prt, msh)
	end
	function MagicBlock2(brickcolor, cframe, Parent, x1, y1, z1, x3, y3, z3, delay)
		local prt = part(3, char, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
		prt.Anchored = false
		prt.CFrame = cframe
		msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
		local wld = weld(prt, prt, Parent, cframe)
		game:GetService("Debris"):AddItem(prt, 5)
		coroutine.resume(coroutine.create(function(Part, Mesh, Weld)
			for i = 0, 1, delay do
				wait()
				Weld.C0 = euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) * cframe
				Part.Transparency = i
				Mesh.Scale = Mesh.Scale + vt(x3, y3, z3)
			end
			Part.Parent = nil
		end), prt, msh, wld)
	end
	function MagicBlock3(brickcolor, cframe, Parent, x1, y1, z1, x3, y3, z3, delay)
		local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
		prt.Anchored = false
		prt.CFrame = cframe
		msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
		local wld = weld(prt, prt, Parent, euler(0, 0, 0) * cf(0, 0, 0))
		game:GetService("Debris"):AddItem(prt, 5)
		coroutine.resume(coroutine.create(function(Part, Mesh, Weld)
			for i = 0, 1, delay do
				wait()
				Weld.C0 = euler(i * 20, 0, 0)
				Part.Transparency = i
				Mesh.Scale = Mesh.Scale + vt(x3, y3, z3)
			end
			Part.Parent = nil
		end), prt, msh, wld)
	end
	function MagicCircle2(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
		prt.Anchored = true
		prt.CFrame = cframe
		local msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 2)
		coroutine.resume(coroutine.create(function(Part, Mesh)
			for i = 0, 1, delay do
				wait()
				Part.CFrame = Part.CFrame
				Mesh.Scale = Mesh.Scale + vt(x3, y3, z3)
				local prt2 = part(3, workspace, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
				prt2.Anchored = true
				prt2.CFrame = cframe * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
				local msh2 = mesh("SpecialMesh", prt2, "Sphere", "", vt(0, 0, 0), vt(0.5, 0.5, 0.5))
				game:GetService("Debris"):AddItem(prt2, 2)
				coroutine.resume(coroutine.create(function(Part, Mesh)
					for i = 0, 1, 0.1 do
						wait()
						Part.CFrame = Part.CFrame * cf(0, 0.5, 0)
					end
					Part.Parent = nil
				end), prt2, msh2)
			end
			for i = 0, 1, delay * 2 do
				wait()
				Part.CFrame = Part.CFrame
				Mesh.Scale = vt(x1 + x3 - (x1 + x3) * i, y1 + y3 - (y1 + y3) * i, z1 + z3 - (z1 + z3) * i)
			end
			Part.Parent = nil
		end), prt, msh)
	end
	function MagicCircle(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
		prt.Anchored = true
		prt.CFrame = cframe
		local msh = mesh("SpecialMesh", prt, "Sphere", "", vt(0, 0, 0), vt(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 2)
		coroutine.resume(coroutine.create(function(Part, Mesh)
			for i = 0, 1, delay do
				wait()
				Part.CFrame = Part.CFrame
				Part.Transparency = i
				Mesh.Scale = Mesh.Scale + vt(x3, y3, z3)
			end
			Part.Parent = nil
		end), prt, msh)
	end
	function BreakEffect(brickcolor, cframe, x1, y1, z1)
		local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
		prt.Anchored = true
		prt.CFrame = cframe * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
		local msh = mesh("SpecialMesh", prt, "Sphere", "", vt(0, 0, 0), vt(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 2)
		coroutine.resume(coroutine.create(function(Part, CF, Numbb, randnumb)
			CF = Part.CFrame
			Numbb = 0
			randnumb = math.random() / 10
			rand1 = math.random() / 10
			for i = 0, 1, rand1 do
				wait()
				CF = CF * cf(0, math.random() / 2, 0)
				Part.CFrame = CF * euler(Numbb, 0, 0)
				Part.Transparency = i
				Numbb = Numbb + randnumb
			end
			Part.Parent = nil
		end), prt, CF, Numbb, randnumb)
	end
	function MagicWaveThing(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
		prt.Anchored = true
		prt.CFrame = cframe
		msh = mesh("SpecialMesh", prt, "FileMesh", "http://www.roblox.com/asset/?id=1051557", vt(0, 0, 0), vt(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 5)
		coroutine.resume(coroutine.create(function(Part, Mesh)
			for i = 0, 1, delay do
				wait()
				Part.CFrame = Part.CFrame * euler(0, 0.7, 0)
				Part.Transparency = i
				Mesh.Scale = Mesh.Scale + vt(x3, y3, z3)
			end
			Part.Parent = nil
		end), prt, msh)
	end
	function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
		prt.Anchored = true
		prt.CFrame = cframe
		msh = mesh("SpecialMesh", prt, "FileMesh", "http://www.roblox.com/asset/?id=20329976", vt(0, 0, 0), vt(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 2)
		coroutine.resume(coroutine.create(function(Part, Mesh)
			for i = 0, 1, delay do
				wait()
				Part.CFrame = Part.CFrame * cf(0, y3 / 2, 0)
				Part.Transparency = i
				Mesh.Scale = Mesh.Scale + vt(x3, y3, z3)
			end
			Part.Parent = nil
		end), prt, msh)
	end
	function StravEffect(brickcolor, cframe, x, y, z, x1, y1, z1, delay)
		local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
		prt.Anchored = true
		prt.CFrame = cframe * cf(x, y, z)
		msh = mesh("SpecialMesh", prt, "FileMesh", "rbxassetid://168892363", vt(0, 0, 0), vt(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 5)
		coroutine.resume(coroutine.create(function(Part, Mesh, ex, why, zee)
			local num = math.random()
			local num2 = math.random(-3, 2) + math.random()
			local numm = 0
			for i = 0, 1, delay * 2 do
				swait()
				Part.CFrame = cframe * euler(0, numm * num * 10, 0) * cf(ex, why, zee) * cf(-i * 10, num2, 0)
				Part.Transparency = i
				numm = numm + 0.01
			end
			Part.Parent = nil
			Mesh.Parent = nil
		end), prt, msh, x, y, z)
	end
	function dmgstart(dmg, what)
		hitcon = what.Touched:connect(function(hit)
			local hum = hit.Parent:FindFirstChild("Humanoid")
			if hum and not hum:IsDescendantOf(Character) then
				hum:TakeDamage(dmg)
			end
		end)
	end
	function dmgstop()
		hitcon:disconnect()
	end
	function Cloak()
		Face.Parent = nil
		cloaked = true
		for _, v in pairs(Torso.Parent:children()) do
			if v.className == "Part" and v.Name ~= "HumanoidRootPart" then
				coroutine.resume(coroutine.create(function()
					for i = 0, 1, 0.2 do
						wait()
						v.Transparency = i
					end
					v.Transparency = 1
				end))
			end
			if v.className == "Hat" then
				hatp = v.Handle
				coroutine.resume(coroutine.create(function(derp)
					for i = 0, 1, 0.2 do
						wait()
						derp.Transparency = i
					end
					derp.Transparency = 1
				end), hatp)
			end
		end
		for _, v in pairs(m:children()) do
			if v.className == "Part" then
				coroutine.resume(coroutine.create(function()
					for i = 0, 1, 0.2 do
						wait()
						v.Transparency = i
					end
					v.Transparency = 1
				end))
			end
		end
	end
	function UnCloak()
		so("http://roblox.com/asset/?id=2767090", Torso, 1, 1.1)
		Face.Parent = Head
		cloaked = false
		for _, v in pairs(Torso.Parent:children()) do
			if v.className == "Part" and v.Name ~= "HumanoidRootPart" then
				coroutine.resume(coroutine.create(function()
					for i = 0, 1, 0.1 do
						wait()
						v.Transparency = v.Transparency - 0.1
					end
					v.Transparency = 0
				end))
			end
			if v.className == "Hat" then
				hatp = v.Handle
				coroutine.resume(coroutine.create(function(derp)
					for i = 0, 1, 0.1 do
						wait()
						derp.Transparency = derp.Transparency - 0.1
					end
					derp.Transparency = 0
				end), hatp)
			end
		end
		for _, v in pairs(m:children()) do
			if v.className == "Part" and v.Name ~= "hitbox" and v.Name ~= "tip" then
				coroutine.resume(coroutine.create(function()
					for i = 0, 1, 0.1 do
						wait()
						v.Transparency = v.Transparency - 0.1
					end
					v.Transparency = 0
				end))
				v.Transparency = 0
			end
		end
	end
	local origcolor = BrickColor.new("Pastel light blue")
	function Explode(rad, par, pitch, vol, mindam, maxdam)
		local expart = Instance.new("Part", char)
		local expart2 = Instance.new("Part", char)
		local rin = Instance.new("Part", char)
		local rin2 = Instance.new("Part", char)
		local partMesh = Instance.new("SpecialMesh", expart)
		partMesh.MeshType = "Sphere"
		local partMesh2 = Instance.new("SpecialMesh", expart2)
		partMesh2.MeshType = "Sphere"
		local partMesh3 = Instance.new("SpecialMesh", rin)
		partMesh3.MeshType = "Brick"
		local partMesh4 = Instance.new("SpecialMesh", rin2)
		partMesh4.MeshType = "Brick"
		CFuncs.Sound.Create("rbxassetid://165970126", expart, vol, pitch)
		partMesh.Scale = vt(rad, rad, rad)
		expart.Size = vt(1, 1, 1)
		expart.Transparency = 0
		expart.Anchored = true
		expart.Material = "Neon"
		expart.BrickColor = bc("White")
		expart.CFrame = par.CFrame
		partMesh2.Scale = vt(rad, rad, rad)
		expart2.Size = vt(1.15, 1.15, 1.15)
		expart2.Transparency = 0.5
		expart2.Anchored = true
		expart2.Material = "Neon"
		expart2.BrickColor = par.BrickColor
		expart2.CFrame = par.CFrame
		rin.Size = vt(1.15, 1.15, 1.15)
		rin.Transparency = 1
		rin.Anchored = true
		rin.Material = "Neon"
		rin.BrickColor = par.BrickColor
		rin.CFrame = par.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)))
		rin2.Size = vt(1.15, 1.15, 1.15)
		rin2.Transparency = 1
		rin2.Anchored = true
		rin2.Material = "Neon"
		rin2.BrickColor = par.BrickColor
		rin2.CFrame = par.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)))
		partMesh3.Scale = vt(0, 1, 0)
		partMesh4.Scale = vt(0, 1, 0)
		local dec2 = Instance.new("Decal", rin)
		dec2.Face = "Top"
		dec2.Texture = "http://www.roblox.com/asset/?id=874580939"
		dec2.Parent = rin
		local dec2b = dec2:Clone()
		dec2b.Face = "Bottom"
		dec2b.Parent = rin
		local dec2a = Instance.new("Decal", rin2)
		dec2a.Face = "Top"
		dec2a.Texture = "http://www.roblox.com/asset/?id=874580939"
		dec2a.Parent = rin2
		local dec2ab = dec2a:Clone()
		dec2ab.Face = "Bottom"
		dec2ab.Parent = rin2
		expart.CanCollide = false
		expart2.CanCollide = false
		rin.CanCollide = false
		rin2.CanCollide = false
		MagniDamage(par, rad * 5, mindam, maxdam, 0, "Normal")
		local value = 1 * rad / 6.5
		for i = 0, 199 do
			partMesh.Scale = partMesh.Scale + vt(value, value, value)
			expart.CFrame = expart.CFrame
			partMesh2.Scale = partMesh2.Scale + vt(value, value, value)
			expart2.CFrame = expart.CFrame
			value = value - 0.035 * rad / 30
			if value < 7.5 then
				partMesh3.Scale = partMesh3.Scale + vt(rad / 5, 0, rad / 5)
				rin.CFrame = rin.CFrame * CFrame.Angles(0, math.rad(1), 0)
				partMesh4.Scale = partMesh4.Scale + vt(rad / 7.5, 0, rad / 7.5)
				rin2.CFrame = rin2.CFrame * CFrame.Angles(0, math.rad(-1), 0)
			end
			if value < 0 then
				dec2.Transparency = dec2.Transparency + 0.025
				dec2a.Transparency = dec2a.Transparency + 0.025
				dec2b.Transparency = dec2b.Transparency + 0.025
				dec2ab.Transparency = dec2ab.Transparency + 0.025
				expart.Transparency = expart.Transparency + 0.025
				expart2.Transparency = expart2.Transparency + 0.025
				rin.Transparency = rin.Transparency + 0.025
				rin2.Transparency = rin2.Transparency + 0.025
			end
			swait()
		end
		game:GetService("Debris"):AddItem(expart, 1)
		game:GetService("Debris"):AddItem(expart2, 1)
		game:GetService("Debris"):AddItem(rin, 1)
		game:GetService("Debris"):AddItem(rin2, 1)
	end
	function ExplodeShort(rad, par, pitch, vol, mindam, maxdam)
		local expart = Instance.new("Part", char)
		local expart2 = Instance.new("Part", char)
		local partMesh = Instance.new("SpecialMesh", expart)
		partMesh.MeshType = "Sphere"
		local partMesh2 = Instance.new("SpecialMesh", expart2)
		partMesh2.MeshType = "Sphere"
		CFuncs.Sound.Create("http://www.roblox.com/asset/?id=142070127", expart, vol, pitch)
		partMesh.Scale = vt(rad, rad, rad)
		expart.Size = vt(1, 1, 1)
		expart.Transparency = 0
		expart.Anchored = true
		expart.Material = "Neon"
		expart.BrickColor = bc("White")
		expart.CFrame = par.CFrame
		partMesh2.Scale = vt(rad, rad, rad)
		expart2.Size = vt(1.15, 1.15, 1.15)
		expart2.Transparency = 0.5
		expart2.Anchored = true
		expart2.Material = "Neon"
		expart2.BrickColor = par.BrickColor
		expart2.CFrame = par.CFrame
		expart.CanCollide = false
		expart2.CanCollide = false
		MagniDamage(par, rad * 2.5, mindam, maxdam, 0, "Normal")
		local value = 1 * rad / 6.5
		for i = 0, 75 do
			partMesh.Scale = partMesh.Scale + vt(value, value, value)
			expart.CFrame = expart.CFrame
			partMesh2.Scale = partMesh2.Scale + vt(value, value, value)
			expart2.CFrame = expart.CFrame
			value = value - 0.035 * rad / 5
			if value < 0 then
				value = 0
				expart.Transparency = expart.Transparency + 0.05
				expart2.Transparency = expart2.Transparency + 0.05
			end
			swait()
		end
		game:GetService("Debris"):AddItem(expart, 1)
		game:GetService("Debris"):AddItem(expart2, 1)
	end
	function AreaDanger(rad, par, mindam, maxdam)
		local expart = Instance.new("Part", char)
		local partMesh = Instance.new("SpecialMesh", expart)
		CFuncs.Sound.Create("rbxassetid://231917784", expart, 1.5, 1.15)
		partMesh.MeshType = "Sphere"
		partMesh.Scale = vt(rad, rad, rad)
		expart.Size = vt(1, 1, 1)
		expart.Transparency = 0.5
		expart.Anchored = true
		expart.Material = "Neon"
		expart.CanCollide = false
		expart.BrickColor = par.BrickColor
		expart.CFrame = par.CFrame
		local value = 1 * rad / 5
		MagicBlock(origcolor, expart.CFrame, 0, 0, 0, rad / 2, rad / 2, rad / 2, 0.1)
		for i = 0, 14 do
			wait()
			partMesh.Scale = partMesh.Scale + vt(value, value, value)
			expart.CFrame = expart.CFrame
			value = value - 0.035 * rad
			if value < 0 then
				value = 0
			end
		end
		wait(0.25)
		CFuncs.Sound.Create("rbxassetid://588738544", expart, 1.5, 1)
		wait(0.5)
		CFuncs.Sound.Create("rbxassetid://588737825", expart, 1.5, 1)
		CFuncs.Sound.Create("rbxassetid://231917784", expart, 1.5, 0.75)
		MagniDamageWithEffect(par, rad, mindam, maxdam, 0, "Normal")
		MagicBlock(origcolor, expart.CFrame, rad * 2, rad * 2, rad * 2, 0.1, 0.1, 0.1, 0.025)
		for i = 0, 14 do
			wait()
			partMesh.Scale = partMesh.Scale + vt(value, value, value)
			expart.CFrame = expart.CFrame
			value = value - 0.035 * rad / 2
		end
		expart.Transparency = 1
		game:GetService("Debris"):AddItem(expart, 5)
	end
	function Swarmsplosions(negrad, rad, par, mindam, maxdam)
		CFuncs.Sound.Create("rbxassetid://588737825", par, 2.5, 2)
		CFuncs.Sound.Create("rbxassetid://231917784", par, 2.5, 1)
		CFuncs.Sound.Create("rbxassetid://231917744", par, 2.5, 1)
		CFuncs.Sound.Create("rbxassetid://233856106", par, 2.5, 1)
		MagniDamageWithEffect(par, 25, 5, 10, 0, "Normal")
		MagicBlock(origcolor, par.CFrame, 5, 5, 5, 5, 5, 5, 0.025)
		for i = 0, 24 do
			MagicShockTrailAlt2(origcolor, par.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 2, 2, 5, -0.01, -0.01, 25, 0.005, math.random(1, 2))
		end
		for i = 0, 24 do
			local expart = Instance.new("Part", char)
			expart.Transparency = 1
			expart.Anchored = true
			expart.CanCollide = false
			expart.CFrame = par.CFrame * CFrame.new(math.random(negrad, rad), math.random(negrad, rad), math.random(negrad, rad))
			CFuncs.Sound.Create("rbxassetid://588737825", expart, 1, 2)
			CFuncs.Sound.Create("rbxassetid://231917784", expart, 1.5, 1.15)
			MagniDamage(expart, rad / 2, mindam, maxdam, 0, "Normal")
			MagicBlock(origcolor, expart.CFrame, rad, rad, rad, 0.1, 0.1, 0.1, 0.025)
			for i = 0, 9 do
				MagicShockTrailAlt2(origcolor, expart.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 2, 2, 5, -0.01, -0.01, 5, 0.05, math.random(1, 2))
			end
			game:GetService("Debris"):AddItem(expart, 2)
			wait(0.1)
		end
	end
	function EXterPlosion(par)
		CFuncs.Sound.Create("rbxassetid://919941001", par, 10, 1)
		CFuncs.Sound.Create("rbxassetid://138213851", par, 5, 0.85)
		CFuncs.Sound.Create("rbxassetid://157878578", par, 5, 0.2)
		CFuncs.Sound.Create("rbxassetid://233856106", par, 2.5, 1)
		MagniDamageWithEffect(par, 500, 80, 99, 0, "Normal")
		MagicBlock(origcolor, par.CFrame, 5, 5, 5, 5, 5, 5, 0.005)
		MagicBlock(origcolor, par.CFrame, 0, 0, 0, 150, 150, 150, 0.1)
		for i = 0, 24 do
			MagicShockTrailAlt2(origcolor, par.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 50, 50, 5, -0.5, -0.5, 500, 0.1, math.random(1, 2))
		end
		for i = 0, 24 do
			MagicShockTrailAlt2(origcolor, par.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 50, 50, 5, -0.25, -0.25, 50, 0.005, math.random(1, 2))
		end
	end
	function ring(type, pos, scale, value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1 * value
		elseif type == "Divide" then
			scaler2 = 1 / value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 10, 0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01 * value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01 / value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
			end
			rng:Destroy()
		end))
	end
	function wave(type, pos, scale, value)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1 * value
		elseif type == "Divide" then
			scaler2 = 1 / value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 10, 0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01 * value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01 / value
				end
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
			end
			rng:Destroy()
		end))
	end
	function wind(type, pos, scale, value, speed)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1 * value
		elseif type == "Divide" then
			scaler2 = 1 / value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 10, 0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01 * value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01 / value
				end
				rng.CFrame = rng.CFrame * CFrame.Angles(0, 0.025 * speed, 0)
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
			end
			rng:Destroy()
		end))
	end
	function groundwind(type, pos, scale, value, speed)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = origcolor
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1 * value
		elseif type == "Divide" then
			scaler2 = 1 / value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 10, 0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01 * value
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01 / value
				end
				rng.CFrame = rng.CFrame * CFrame.Angles(0, 0.025 * speed, 0)
				rng.Transparency = rng.Transparency + 0.01
				rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2 / 5, scaler2)
			end
			rng:Destroy()
		end))
	end
	function CameraManager()
		if TwoD and not CamInterrupt then
			if Humanoid.Health > 0 then
				Camera.CameraSubject = Humanoid
				Camera.CameraType = "Scriptable"
				Humanoid.AutoRotate = false
				if Booleans.GyroUse then
					Directer.MaxTorque = Vec3(0, huge, 0)
				else
					Directer.MaxTorque = Vec3(0, 0, 0)
				end
				if TargetInfo[1] ~= nil and TargetInfo[2] ~= nil then
					if Booleans.CamFollow then
						CPart.CFrame = cFrame(RootPart.Position, Vec3(TargetInfo[1].Position.X, RootPart.Position.Y, TargetInfo[1].Position.Z))
						Directer.CFrame = cFrame((RootPart.CFrame * cFrame(0, 0, 10)).p, TargetInfo[1].Position)
					else
						CPart.Position = RootPart.Position
					end
				else
					local ahead = (RootPart.CFrame * cFrame(0, 0, -3)).p
					CPart.CFrame = cFrame(RootPart.Position, Vec3(ahead.X, RootPart.Position.Y, ahead.Z))
				end
				Camera.CFrame = lerp(Camera.CFrame, CPart.CFrame * cFrame(25, 3, 0) * Euler(0, radian(90), 0), 0.2)
			else
				Camera.CameraSubject = Humanoid
				Camera.CameraType = "Custom"
				--			Controller.Disabled = false
			end
		end
	end
	function sphere(bonuspeed, type, pos, scale, value, color)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = scale
		if rainbowmode == true then
			rng.Color = Color3.new(r / 255, g / 255, b / 255)
		end
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1 * value
		elseif type == "Divide" then
			scaler2 = 1 / value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 10 / bonuspeed, 0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r / 255, g / 255, b / 255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01 * value / bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01 / value * bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				rng.Transparency = rng.Transparency + 0.01 * bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
			end
			rng:Destroy()
		end))
	end
	function sphereMK(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = vt(x1, y1, z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r / 255, g / 255, b / 255)
		end
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1 * value
		elseif type == "Divide" then
			scaler2 = 1 / value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 10 / bonuspeed, 0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r / 255, g / 255, b / 255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01 * value / bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01 / value * bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder - 0.01 * FastSpeed * bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
				rng.Transparency = rng.Transparency + 0.01 * bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end
	function sphereMKCharge(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 1
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = "Sphere"
		rngm.Scale = vt(x1, y1, z1)
		if rainbowmode == true then
			rng.Color = Color3.new(r / 255, g / 255, b / 255)
		end
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1 * value
		elseif type == "Divide" then
			scaler2 = 1 / value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 10 / bonuspeed, 0.1 do
				swait()
				if rainbowmode == true then
					rng.Color = Color3.new(r / 255, g / 255, b / 255)
				end
				if type == "Add" then
					scaler2 = scaler2 - 0.01 * value / bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01 / value * bonuspeed
				end
				if chaosmode == true then
					rng.BrickColor = BrickColor.random()
				end
				speeder = speeder - 0.01 * FastSpeed * bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
				rng.Transparency = rng.Transparency - 0.01 * bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end
	function dmg(dude)
		if dude.Name ~= Character then
			local bgf = Instance.new("BodyGyro", dude.Head)
			bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90), 0, 0)
			local val = Instance.new("BoolValue", dude)
			val.Name = "IsHit"
			local ds = coroutine.wrap(function()
				dude:WaitForChild("Head"):BreakJoints()
				wait(0.5)
				targetted = nil
				CFuncs.Sound.Create("rbxassetid://62339698", char, 0.5, 0.3)
				coroutine.resume(coroutine.create(function()
					for i, v in pairs(dude:GetChildren()) do
						if v:IsA("Accessory") then
							v:Destroy()
						end
						if v:IsA("Humanoid") then
							v:Destroy()
						end
						if v:IsA("CharacterMesh") then
							v:Destroy()
						end
						if v:IsA("Model") then
							v:Destroy()
						end
						if v:IsA("Part") or v:IsA("MeshPart") then
							for x, o in pairs(v:GetChildren()) do
								if o:IsA("Decal") then
									o:Destroy()
								end
							end
							coroutine.resume(coroutine.create(function()
								v.Material = "Neon"
								v.CanCollide = false
								local bld = Instance.new("ParticleEmitter", v)
								bld.LightEmission = 1
								bld.Texture = "rbxassetid://284205403"
								bld.Color = ColorSequence.new(Color3.new(1, 1, 1))
								bld.Rate = 50
								bld.Lifetime = NumberRange.new(1)
								bld.Size = NumberSequence.new({
									NumberSequenceKeypoint.new(0, 0.75, 0),
									NumberSequenceKeypoint.new(1, 0, 0)
								})
								bld.Transparency = NumberSequence.new({
									NumberSequenceKeypoint.new(0, 0, 0),
									NumberSequenceKeypoint.new(1, 1, 0)
								})
								bld.Speed = NumberRange.new(0, 0)
								bld.VelocitySpread = 50000
								bld.Rotation = NumberRange.new(-500, 500)
								bld.RotSpeed = NumberRange.new(-500, 500)
								local sbs = Instance.new("BodyPosition", v)
								sbs.P = 3000
								sbs.D = 1000
								sbs.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
								sbs.position = v.Position + Vector3.new(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5))
								v.Color = Color3.new(1, 1, 1)
								coroutine.resume(coroutine.create(function()
									for i = 0, 49 do
										swait(1)
										v.Transparency = v.Transparency + 0.02
									end
									CFuncs.Sound.Create("rbxassetid://1192402877", v, 0.25, 1)
									bld.Speed = NumberRange.new(1, 5)
									bld.Acceleration = vt(0, 10, 0)
									wait(0.5)
									bld.Enabled = false
									wait(3)
									v:Destroy()
									dude:Destroy()
								end))
							end))
						end
					end
				end))
			end)
			ds()
		end
	end
	function FindNearestHead(Position, Distance, SinglePlayer)
		if SinglePlayer then
			return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
		end
		local List = {}
		for i, v in pairs(workspace:GetChildren()) do
			if v:IsA("Model") and v:findFirstChild("Head") and v ~= Character and Distance >= (v.Head.Position - Position).magnitude then
				table.insert(List, v)
			end
		end
		return List
	end
	function FaceMouse()
		Cam = workspace.CurrentCamera
		return {
			CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
			Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
		}
	end
	function FaceMouse2()
		Cam = workspace.CurrentCamera
		return {
			CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)),
			Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
		}
	end
	local ModeOfGlitch = 1
	local storehumanoidWS = 16
	function ExtinctiveHeartbreak()
		local targetted
		if mouse.Target.Parent ~= Character and mouse.Target.Parent.Parent ~= Character and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
			targetted = mouse.Target.Parent
		end
		if targetted ~= nil then
			attack = true
			CFuncs.Sound.Create("rbxassetid://847061203", root, 2.5, 1)
			for i = 0, 9 do
				sphereMK(3, 0.25, "Add", root.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 1, 1, 10, -0.01, BrickColor.new("Really black"), 0)
			end
			sphere(3, "Add", root.CFrame, vt(0, 0, 0), 0.25, BrickColor.new("Really black"))
			local originalpos = root.CFrame
			RootPart.CFrame = targetted.Head.CFrame * CFrame.new(0, -2, 2)
			for i = 0, 9 do
				sphereMK(3, 0.25, "Add", root.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 1, 1, 10, -0.01, BrickColor.new("Really black"), 0)
			end
			hum.WalkSpeed = 0
			targetted.Head.Anchored = true
			sphere(3, "Add", root.CFrame, vt(0, 0, 0), 0.25, BrickColor.new("Really black"))
			for i = 0, 2, 0.1 do
				swait()
				RH.C0 = clerp(RH.C0, cf(1, -1 - 0.05 * math.cos(sine / 28), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(0)), 0.4)
				LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.05 * math.cos(sine / 28), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(0)), 0.4)
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0 + 0.05 * math.cos(sine / 28)) * angles(math.rad(0), math.rad(0), math.rad(80)), 0.4)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(20), math.rad(0), math.rad(10)), 0.8)
				RW.C0 = clerp(RW.C0, cf(1.5, 0.5 + 0.1 * math.cos(sine / 28), 0) * angles(math.rad(20), math.rad(0), math.rad(10)), 0.4)
				LW.C0 = clerp(LW.C0, cf(-1.5, 0.5 + 0.1 * math.cos(sine / 28), 0) * angles(math.rad(90), math.rad(0), math.rad(60)), 0.4)
			end
			coroutine.resume(coroutine.create(function()
				bld = Instance.new("ParticleEmitter", targetted:WaitForChild("Torso"))
				bld.LightEmission = 0.1
				bld.Texture = "rbxassetid://284205403"
				bld.Color = ColorSequence.new(Color3.new(0.5, 0, 0))
				bld.Rate = 500
				bld.Lifetime = NumberRange.new(1)
				bld.Size = NumberSequence.new({
					NumberSequenceKeypoint.new(0, 2, 0),
					NumberSequenceKeypoint.new(1, 0, 0)
				})
				bld.Acceleration = vt(0, -25, 0)
				bld.Transparency = NumberSequence.new({
					NumberSequenceKeypoint.new(0, 0, 0),
					NumberSequenceKeypoint.new(1, 0, 0)
				})
				bld.Speed = NumberRange.new(10, 50)
				bld.EmissionDirection = "Front"
				bld.VelocitySpread = 25
				bld.Rotation = NumberRange.new(-500, 500)
				bld.RotSpeed = NumberRange.new(-500, 500)
			end))
			coroutine.resume(coroutine.create(function()
				bld = Instance.new("ParticleEmitter", targetted:WaitForChild("UpperTorso"))
				bld.LightEmission = 0.1
				bld.Texture = "rbxassetid://284205403"
				bld.Color = ColorSequence.new(Color3.new(0.5, 0, 0))
				bld.Rate = 500
				bld.Lifetime = NumberRange.new(1)
				bld.Size = NumberSequence.new({
					NumberSequenceKeypoint.new(0, 2, 0),
					NumberSequenceKeypoint.new(1, 0, 0)
				})
				bld.Acceleration = vt(0, -25, 0)
				bld.Transparency = NumberSequence.new({
					NumberSequenceKeypoint.new(0, 0, 0),
					NumberSequenceKeypoint.new(1, 0, 0)
				})
				bld.Speed = NumberRange.new(10, 50)
				bld.EmissionDirection = "Front"
				bld.VelocitySpread = 25
				bld.Rotation = NumberRange.new(-500, 500)
				bld.RotSpeed = NumberRange.new(-500, 500)
			end))
			CameraEnshaking(5, 5)
			game:GetService("Debris"):AddItem(bld, 3)
			dmg(targetted)
			CFuncs.Sound.Create("rbxassetid://429400881", targetted.Head, 1, 1)
			for i = 0, 1, 0.1 do
				swait()
				RH.C0 = clerp(RH.C0, cf(1, -1 - 0.05 * math.cos(sine / 28), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(0)), 0.8)
				LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.05 * math.cos(sine / 28), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(0)), 0.8)
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0.25, 0 + 0.05 * math.cos(sine / 28)) * angles(math.rad(0), math.rad(0), math.rad(-80)), 0.8)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(20), math.rad(0), math.rad(80)), 0.8)
				RW.C0 = clerp(RW.C0, cf(1.5, 0.5 + 0.1 * math.cos(sine / 28), 0) * angles(math.rad(20), math.rad(0), math.rad(10)), 0.8)
				LW.C0 = clerp(LW.C0, cf(-1.5, 0.5 + 0.1 * math.cos(sine / 28), 0) * angles(math.rad(90), math.rad(0), math.rad(-80)), 0.8)
			end
			CFuncs.Sound.Create("rbxassetid://847061203", root, 2.5, 1)
			for i = 0, 9 do
				sphereMK(3, 0.25, "Add", root.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 1, 1, 10, -0.01, BrickColor.new("Really black"), 0)
			end
			sphere(3, "Add", root.CFrame, vt(0, 0, 0), 0.25, BrickColor.new("Really black"))
			root.CFrame = originalpos
			for i = 0, 9 do
				sphereMK(3, 0.25, "Add", root.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 1, 1, 10, -0.01, BrickColor.new("Really black"), 0)
			end
			sphere(3, "Add", root.CFrame, vt(0, 0, 0), 0.25, BrickColor.new("Really black"))
			bld.Enabled = false
			attack = false
			hum.WalkSpeed = storehumanoidWS
		end
	end
	function PureBomb()
		attack = true
		local orb = Instance.new("Part", char)
		orb.Anchored = true
		orb.BrickColor = BrickColor.new("Toothpaste")
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 0
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(0, 0, 0)
		local scaled = 0.1
		local posid = 0
		CFuncs.Sound.Create("rbxassetid://136007472", orb, 1, 1)
		for i = 0, 5, 0.1 do
			swait()
			scaled = scaled - 0.001
			posid = posid - scaled
			orb.CFrame = rarm.CFrame * CFrame.new(0, -0.1 + posid / 1.05, 0)
			orbm.Scale = orbm.Scale + vt(scaled, scaled, scaled)
			sphereMKCharge(5, -0.25, "Add", orb.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 0.5, 0.5, 5, -0.005, BrickColor.new("Toothpaste"), 10)
			RH.C0 = clerp(RH.C0, cf(1, -1 - 0.1 * math.cos(sine / 32), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(-2 - 1 * math.cos(sine / 32))), 0.1)
			LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.1 * math.cos(sine / 32), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-3 + 1 * math.cos(sine / 32)), math.rad(0), math.rad(-10)), 0.1)
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0 + 0.1 * math.cos(sine / 32)) * angles(math.rad(0), math.rad(0), math.rad(0)), 0.1)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(0)), 0.1)
			RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(180), math.rad(20), math.rad(0)), 0.1)
			LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(-30 + 5 * math.cos(sine / 30)), math.rad(-20)), 0.1)
		end
		for i = 0, 2, 0.1 do
			swait()
			orb.CFrame = rarm.CFrame * CFrame.new(0, -0.1 + posid / 1.05, 0)
			RH.C0 = clerp(RH.C0, cf(1, -1 - 0.1 * math.cos(sine / 32), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(-2 - 1 * math.cos(sine / 32))), 0.4)
			LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.1 * math.cos(sine / 32), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-3 + 1 * math.cos(sine / 32)), math.rad(0), math.rad(-10)), 0.4)
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0 + 0.1 * math.cos(sine / 32)) * angles(math.rad(0), math.rad(0), math.rad(-50)), 0.4)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(20)), 0.4)
			RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(220), math.rad(20), math.rad(0)), 0.4)
			LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(-30 + 5 * math.cos(sine / 30)), math.rad(-20)), 0.4)
		end
		coroutine.resume(coroutine.create(function()
			orb.Anchored = false
			CFuncs.Sound.Create("rbxassetid://260433768", root, 1.25, 1)
			local a = Instance.new("Part", workspace)
			a.Name = "Direction"
			a.Anchored = true
			a.BrickColor = bc("Bright red")
			a.Material = "Neon"
			a.Transparency = 1
			a.CanCollide = false
			local ray = Ray.new(orb.CFrame.p, (mouse.Hit.p - orb.CFrame.p).unit * 500)
			local ignore = orb
			local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			a.BottomSurface = 10
			a.TopSurface = 10
			local distance = (orb.CFrame.p - position).magnitude
			a.Size = Vector3.new(0.1, 0.1, 0.1)
			a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, 0)
			orb.CFrame = a.CFrame
			a:Destroy()
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
			bv.velocity = orb.CFrame.lookVector * 125
			bv.Parent = orb
			local hitted = false
			game:GetService("Debris"):AddItem(orb, 15)
			wait()
			local hit = orb.Touched:connect(function(hit)
				if hitted == false then
					hitted = true
					CameraEnshaking(10, 2.5)
					CFuncs.Sound.Create("rbxassetid://151304356", orb, 5, 1)
					MagniDamage(orb, 65, 65, 90, 0, "Normal")
					sphere(1, "Add", orb.CFrame, vt(orbm.Scale.x, orbm.Scale.y, orbm.Scale.z), 1, BrickColor.new("Toothpaste"))
					sphere(2, "Add", orb.CFrame, vt(orbm.Scale.x, orbm.Scale.y, orbm.Scale.z), 2, BrickColor.new("Toothpaste"))
					for i = 0, 9 do
						sphereMK(1, 2.5, "Add", orb.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 5, 5, 50, -0.05, BrickColor.new("Toothpaste"), 0)
						sphereMK(2, 5, "Add", orb.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 5, 5, 50, -0.05, BrickColor.new("Toothpaste"), 0)
					end
					orb.Anchored = true
					orb.Transparency = 1
					wait(8)
					orb:Destroy()
				end
			end)
		end))
		for i = 0, 1, 0.1 do
			swait()
			RH.C0 = clerp(RH.C0, cf(1, -1 - 0.1 * math.cos(sine / 32), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(-2 - 1 * math.cos(sine / 32))), 0.4)
			LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.1 * math.cos(sine / 32), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-3 + 1 * math.cos(sine / 32)), math.rad(0), math.rad(-10)), 0.4)
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0 + 0.1 * math.cos(sine / 32)) * angles(math.rad(0), math.rad(0), math.rad(50)), 0.4)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(20), math.rad(0), math.rad(-50)), 0.4)
			RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(60), math.rad(20), math.rad(50)), 0.4)
			LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(-30 + 5 * math.cos(sine / 30)), math.rad(-20)), 0.4)
		end
		attack = false
	end
	function ChaosGroundStrike()
		attack = true
		for i = 0, 2, 0.1 do
			swait()
			RH.C0 = clerp(RH.C0, cf(1, -0.25, -0.5) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(20)), 0.2)
			LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(20)), 0.2)
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * angles(math.rad(-20), math.rad(0), math.rad(0)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-20), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(140), math.rad(0), math.rad(-20)), 0.2)
			LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(140), math.rad(0), math.rad(20)), 0.2)
		end
		CFuncs.Sound.Create("rbxassetid://438666141", root, 7.5, 1)
		CFuncs.Sound.Create("rbxassetid://1208650519", root, 7.5, 1)
		CameraEnshaking(4, 12)
		for i, v in pairs(FindNearestHead(Torso.CFrame.p, 52.5)) do
			if v:FindFirstChild("Head") then
				dmg(v)
			end
		end
		sphere(5, "Add", root.CFrame * CFrame.new(0, -2.9, 0), vt(0, 0, 0), 1, BrickColor.random())
		sphere(10, "Add", root.CFrame * CFrame.new(0, -2.9, 0), vt(0, 0, 0), 2, BrickColor.random())
		sphere(1, "Add", root.CFrame * CFrame.new(0, -2.9, 0), vt(100, 0.1, 100), 0.01, BrickColor.random())
		for i = 0, 2, 0.1 do
			swait()
			sphereMK(2.5, 0.75, "Add", root.CFrame * CFrame.new(math.random(-52.5, 52.5), -5, math.random(-52.5, 52.5)) * CFrame.Angles(math.rad(90 + math.rad(math.random(-45, 45))), math.rad(math.random(-45, 45)), math.rad(math.random(-45, 45))), 2.5, 2.5, 25, -0.025, BrickColor.random(), 0)
			sphereMK(2.5, 0.75, "Add", root.CFrame * CFrame.new(math.random(-52.5, 52.5), -5, math.random(-52.5, 52.5)) * CFrame.Angles(math.rad(90 + math.rad(math.random(-45, 45))), math.rad(math.random(-45, 45)), math.rad(math.random(-45, 45))), 2.5, 2.5, 25, -0.025, BrickColor.random(), 0)
			RH.C0 = clerp(RH.C0, cf(1, -1, -0.5) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(10)), 0.4)
			LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(10)), 0.4)
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
			RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(-50), math.rad(0), math.rad(30)), 0.4)
			LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(-50), math.rad(0), math.rad(-30)), 0.4)
		end
		attack = false
	end
	function ChaosBegone()
		attack = true
		chatfunc("WHY WONT YOU PEOPLE...", BrickColor.random().Color)
		for i = 0, 10, 0.1 do
			swait()
			RH.C0 = clerp(RH.C0, cf(1, -0.25, -0.5) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(20)), 0.2)
			LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(20)), 0.2)
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * angles(math.rad(-20), math.rad(0), math.rad(0)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-20), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(140), math.rad(0), math.rad(-20)), 0.2)
			LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(140), math.rad(0), math.rad(20)), 0.2)
		end
		chatfunc("DIE!!", BrickColor.random().Color)
		CFuncs.Sound.Create("rbxassetid://438666141", char, 7.5, 1)
		CFuncs.Sound.Create("rbxassetid://1208650519", char, 7.5, 1)
		CameraEnshaking(5, 25)
		for i, v in pairs(FindNearestHead(Torso.CFrame.p, 1234567890)) do
			if v:FindFirstChild("Head") then
				dmg(v)
			end
		end
		sphere(5, "Add", root.CFrame * CFrame.new(0, -2.9, 0), vt(0, 0, 0), 1000, BrickColor.random())
		sphere(10, "Add", root.CFrame * CFrame.new(0, -2.9, 0), vt(0, 0, 0), 2000, BrickColor.random())
		sphere(1, "Add", root.CFrame * CFrame.new(0, -2.9, 0), vt(100000, 0.1, 100000), 0.01, BrickColor.random())
		for i = 0, 3, 0.1 do
			swait()
			sphereMK(2.5, 0.75, "Add", root.CFrame * CFrame.new(math.random(-525, 525), -5, math.random(-525, 525)) * CFrame.Angles(math.rad(90 + math.rad(math.random(-45, 45))), math.rad(math.random(-45, 45)), math.rad(math.random(-45, 45))), 2.5, 2.5, 25, -0.025, BrickColor.random(), 0)
			sphereMK(2.5, 0.75, "Add", root.CFrame * CFrame.new(math.random(-525, 525), -5, math.random(-525, 525)) * CFrame.Angles(math.rad(90 + math.rad(math.random(-45, 45))), math.rad(math.random(-45, 45)), math.rad(math.random(-45, 45))), 2.5, 2.5, 25, -0.025, BrickColor.random(), 0)
			sphereMK(2.5, 0.75, "Add", root.CFrame * CFrame.new(math.random(-525, 525), -5, math.random(-525, 525)) * CFrame.Angles(math.rad(90 + math.rad(math.random(-45, 45))), math.rad(math.random(-45, 45)), math.rad(math.random(-45, 45))), 2.5, 2.5, 25, -0.025, BrickColor.random(), 0)
			sphereMK(2.5, 0.75, "Add", root.CFrame * CFrame.new(math.random(-525, 525), -5, math.random(-525, 525)) * CFrame.Angles(math.rad(90 + math.rad(math.random(-45, 45))), math.rad(math.random(-45, 45)), math.rad(math.random(-45, 45))), 2.5, 2.5, 25, -0.025, BrickColor.random(), 0)
			RH.C0 = clerp(RH.C0, cf(1, -1, -0.5) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(10)), 0.4)
			LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(10)), 0.4)
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
			RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(-50), math.rad(0), math.rad(30)), 0.4)
			LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(-50), math.rad(0), math.rad(-30)), 0.4)
		end
		attack = false
	end
	function orb_spawn_norm(positted, timer, color, MagniBoost, min, max, volEx, ShakePower, volSummon)
		local orb = Instance.new("Part", char)
		orb.Anchored = true
		orb.BrickColor = color
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 0
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orb.CFrame = positted
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(1, 1, 1)
		CFuncs.Sound.Create("rbxassetid://183763506", orb, volSummon, 1)
		sphere(2.5, "Add", orb.CFrame, vt(1, 1, 1), 0.05, orb.BrickColor)
		coroutine.resume(coroutine.create(function()
			wait(timer)
			CameraEnshaking(3, ShakePower)
			orb.Transparency = 1
			MagniDamage(orb, 3.5 * MagniBoost, min, max, 0, "Normal")
			sphere(5, "Add", orb.CFrame, vt(1, 1, 1), 0.1 * MagniBoost, orb.BrickColor)
			CFuncs.Sound.Create("rbxassetid://192410089", orb, volEx, 0.7)
			wait(3)
			orb:Destroy()
		end))
	end
	function orb_spawn(positted, timer)
		local randomcol = math.random(1, 2)
		local orb = Instance.new("Part", char)
		orb.Anchored = true
		if randomcol == 1 then
			orb.BrickColor = BrickColor.new("White")
		elseif randomcol == 2 then
			orb.BrickColor = BrickColor.new("Really black")
		end
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 0
		orb.TopSurface = 0
		orb.BottomSurface = 0
		local orbm = Instance.new("SpecialMesh", orb)
		orbm.MeshType = "Sphere"
		orb.CFrame = positted
		orbm.Name = "SizeMesh"
		orbm.Scale = vt(1, 1, 1)
		CFuncs.Sound.Create("rbxassetid://183763506", orb, 1.5, 1)
		sphere(2.5, "Add", orb.CFrame, vt(1, 1, 1), 0.025, orb.BrickColor)
		for i = 0, 2 do
			sphereMK(5, 0.15, "Add", orb.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 1.5, 1.5, 7.5, -0.015, orb.BrickColor, 0)
		end
		coroutine.resume(coroutine.create(function()
			wait(timer)
			CameraEnshaking(3, 2)
			orb.Transparency = 1
			MagniDamage(orb, 17.5, 10, 50, 0, "Normal")
			sphere(5, "Add", orb.CFrame, vt(1, 1, 1), 0.5, orb.BrickColor)
			for i = 0, 4 do
				sphereMK(5, 0.65, "Add", orb.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 2.5, 2.5, 15, -0.025, orb.BrickColor, 0)
			end
			CFuncs.Sound.Create("rbxassetid://192410089", orb, 2, 0.7)
			wait(3)
			orb:Destroy()
		end))
	end
	function scattercorrupt()
		attack = true
		local rot = 0
		local randomrotations = math.random(1, 2)
		local lookv = 2.5
		local power = 5
		sphere(1, "Add", root.CFrame, vt(1, 100000, 1), 0.5, BrickColor.new("Royal purple"))
		sphere(1, "Add", root.CFrame, vt(1, 1, 1), 0.75, BrickColor.new("Royal purple"))
		for i = 0, 9 do
			sphereMK(1, 1.5, "Add", root.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 10, 10, 45, -0.1, BrickColor.new("Royal purple"), 0)
		end
		CFuncs.Sound.Create("rbxassetid://180204650", char, 2.5, 0.6)
		CFuncs.Sound.Create("rbxassetid://233856079", char, 1, 0.5)
		CFuncs.Sound.Create("rbxassetid://1208650519", char, 2.5, 1)
		CFuncs.Sound.Create("rbxassetid://239000203", char, 0.5, 0.75)
		CFuncs.Sound.Create("rbxassetid://579687077", char, 0.5, 0.5)
		local hite = Instance.new("Part", char)
		hite.Anchored = true
		hite.CanCollide = false
		hite.FormFactor = 3
		hite.Name = "Ring"
		hite.Material = "Neon"
		hite.Size = Vector3.new(1, 1, 1)
		hite.Transparency = 1
		hite.TopSurface = 0
		hite.BottomSurface = 0
		hite.CFrame = root.CFrame * CFrame.new(0, -2.5, 0)
		local rem = Instance.new("Part", char)
		rem.Anchored = true
		rem.CanCollide = false
		rem.FormFactor = 3
		rem.Name = "Ring"
		rem.Material = "Neon"
		rem.Size = Vector3.new(1, 1, 1)
		rem.Transparency = 1
		rem.TopSurface = 0
		rem.BottomSurface = 0
		rem.CFrame = hite.CFrame
		local rem2 = rem:Clone()
		rem2.Parent = char
		rem2.CFrame = rem.CFrame * CFrame.Angles(0, math.rad(90), 0)
		local rem3 = rem:Clone()
		rem3.Parent = char
		rem3.CFrame = rem.CFrame * CFrame.Angles(0, math.rad(180), 0)
		local rem4 = rem:Clone()
		rem4.Parent = char
		rem4.CFrame = rem.CFrame * CFrame.Angles(0, math.rad(270), 0)
		hite:Destroy()
		coroutine.resume(coroutine.create(function()
			for i = 0, 24 do
				swait(1)
				if randomrotations == 1 then
					rot = rot + 1
				elseif randomrotations == 2 then
					rot = rot - 1
				end
				power = power + 0.5
				lookv = lookv + 7.5
				rem.CFrame = rem.CFrame * CFrame.Angles(0, math.rad(rot), 0)
				rem2.CFrame = rem.CFrame * CFrame.Angles(0, math.rad(90), 0)
				rem3.CFrame = rem.CFrame * CFrame.Angles(0, math.rad(180), 0)
				rem4.CFrame = rem.CFrame * CFrame.Angles(0, math.rad(270), 0)
				orb_spawn_norm(rem.CFrame + rem.CFrame.lookVector * lookv, 3, BrickColor.new("Royal purple"), power, 25, 75, 10, power / 5, 7.5)
				orb_spawn_norm(rem2.CFrame + rem2.CFrame.lookVector * lookv, 3, BrickColor.new("Royal purple"), power, 25, 75, 10, power / 5, 7.5)
				orb_spawn_norm(rem3.CFrame + rem3.CFrame.lookVector * lookv, 3, BrickColor.new("Royal purple"), power, 25, 75, 10, power / 5, 7.5)
				orb_spawn_norm(rem4.CFrame + rem4.CFrame.lookVector * lookv, 3, BrickColor.new("Royal purple"), power, 25, 75, 10, power / 5, 7.5)
			end
		end))
		attack = false
	end
	function yinyangi()
		attack = true
		for i = 0, 2, 0.1 do
			swait()
			RH.C0 = clerp(RH.C0, cf(1, -0.25, -0.5) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(-20)), 0.2)
			LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(20)), 0.2)
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, -0.5, 0.5 + 0.1 * math.cos(sine / 28)) * angles(math.rad(75), math.rad(0), math.rad(0)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-20), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), 0.2)
			LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-90)), 0.2)
		end
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
		bv.velocity = root.CFrame.lookVector * 175
		bv.Parent = root
		for Rotations = 0, 9 do
			for i = 0, 1, 0.5 do
				swait()
				bv.velocity = root.CFrame.lookVector * 175
				RH.C0 = clerp(RH.C0, cf(1, -0.25, -0.5) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(-20)), 0.5)
				LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(20)), 0.5)
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, -0.5, 0.5 + 0.1 * math.cos(sine / 28)) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.5)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-20), math.rad(0), math.rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), 0.5)
				LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-90)), 0.5)
			end
			orb_spawn(rarm.CFrame * CFrame.new(0, -1, 0), 2.5)
			for i = 0, 1, 0.5 do
				swait()
				bv.velocity = root.CFrame.lookVector * 175
				RH.C0 = clerp(RH.C0, cf(1, -0.25, -0.5) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(-20)), 0.5)
				LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(20)), 0.5)
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, -0.5, 0.5 + 0.1 * math.cos(sine / 28)) * angles(math.rad(90), math.rad(0), math.rad(180)), 0.5)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-20), math.rad(0), math.rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), 0.5)
				LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-90)), 0.5)
			end
			orb_spawn(rarm.CFrame * CFrame.new(0, -1, 0), 2.5)
			for i = 0, 1, 0.5 do
				swait()
				bv.velocity = root.CFrame.lookVector * 175
				RH.C0 = clerp(RH.C0, cf(1, -0.25, -0.5) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(-20)), 0.5)
				LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(20)), 0.5)
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, -0.5, 0.5 + 0.1 * math.cos(sine / 28)) * angles(math.rad(90), math.rad(0), math.rad(270)), 0.5)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-20), math.rad(0), math.rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), 0.5)
				LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-90)), 0.5)
			end
			orb_spawn(rarm.CFrame * CFrame.new(0, -1, 0), 2.5)
			for i = 0, 1, 0.5 do
				swait()
				bv.velocity = root.CFrame.lookVector * 175
				RH.C0 = clerp(RH.C0, cf(1, -0.25, -0.5) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(-20)), 0.5)
				LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(20)), 0.5)
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, -0.5, 0.5 + 0.1 * math.cos(sine / 28)) * angles(math.rad(90), math.rad(0), math.rad(360)), 0.5)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-20), math.rad(0), math.rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), 0.5)
				LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-90)), 0.5)
			end
			orb_spawn(rarm.CFrame * CFrame.new(0, -1, 0), 2.5)
		end
		bv:Destroy()
		attack = false
	end
	function Wip()
		attack = true
		local rngb = Instance.new("Part", char)
		rngb.Anchored = true
		rngb.BrickColor = origcolor
		rngb.CanCollide = false
		rngb.FormFactor = 3
		rngb.Name = "Ring"
		rngb.Material = "Neon"
		rngb.Size = Vector3.new(1, 0.05, 1)
		rngb.Transparency = 1
		rngb.TopSurface = 0
		rngb.BottomSurface = 0
		local rngmb = Instance.new("SpecialMesh", rngb)
		rngmb.MeshType = "Brick"
		rngmb.Name = "SizeMesh"
		rngmb.Scale = vt(0, 1, 0)
		local orb = rngb:Clone()
		orb.Parent = char
		orb.Transparency = 0
		orb.BrickColor = BrickColor.new("White")
		orb.Size = vt(1, 1, 1)
		local orbmish = orb.SizeMesh
		orbmish.Scale = vt(0, 0, 0)
		orbmish.MeshType = "Sphere"
		local orbe = rngb:Clone()
		orbe.Parent = char
		orbe.Transparency = 0.5
		orbe.BrickColor = BrickColor.new("New Yeller")
		orbe.Size = vt(1, 1, 1)
		local orbmish2 = orbe.SizeMesh
		orbmish2.Scale = vt(0, 0, 0)
		orbmish2.MeshType = "Sphere"
		orbe.Color = Color3.new(r / 255, g / 255, b / 255)
		rngb:Destroy()
		for i = 0, 5, 0.1 do
			swait()
			if rainbowmode == true then
				orbe.Color = Color3.new(r / 255, g / 255, b / 255)
			end
			orb.CFrame = root.CFrame * CFrame.new(0, 0.5, 0) + root.CFrame.lookVector * 11.5
			orbe.CFrame = root.CFrame * CFrame.new(0, 0.5, 0) + root.CFrame.lookVector * 11.5
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), 0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-90)), 0.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
			RH.C0 = clerp(RH.C0, cf(1, -1 - 0.05 * math.cos(sine / 25), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-0.5), math.rad(0), math.rad(0)), 0.3)
			LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.05 * math.cos(sine / 25), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-2.5), math.rad(10), math.rad(0)), 0.3)
			RootPart.CFrame = FaceMouse()[1]
		end
		orbe.Transparency = 1
		orb.Transparency = 1
		orb.CFrame = root.CFrame * CFrame.new(0, 0.5, 0) + root.CFrame.lookVector * 5
		CFuncs.Sound.Create("rbxassetid://294188875", char, 1, 1)
		local a = Instance.new("Part", Character)
		a.Name = "Direction"
		a.Anchored = true
		a.BrickColor = bc("White")
		a.Material = "Neon"
		a.Transparency = 0
		a.Shape = "Cylinder"
		a.CanCollide = false
		local a2 = Instance.new("Part", Character)
		a2.Name = "Direction"
		a2.Anchored = true
		a2.BrickColor = bc("New Yeller")
		a2.Color = Color3.new(r / 255, g / 255, b / 255)
		a2.Material = "Neon"
		a2.Transparency = 0.5
		a2.Shape = "Cylinder"
		a2.CanCollide = false
		local ba = Instance.new("Part", Character)
		ba.Name = "HitDirect"
		ba.Anchored = true
		ba.BrickColor = bc("Really black")
		ba.Material = "Neon"
		ba.Transparency = 1
		ba.CanCollide = false
		local ray = Ray.new(orb.CFrame.p, (mouse.Hit.p - orb.CFrame.p).unit * 1000)
		local ignore = Character
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		a2.BottomSurface = 10
		a2.TopSurface = 10
		local distance = (orb.CFrame.p - position).magnitude
		a.Size = Vector3.new(distance, 1, 1)
		a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance / 2)
		a2.Size = Vector3.new(distance, 1, 1)
		a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance / 2)
		ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
		a.CFrame = a.CFrame * CFrame.Angles(0, math.rad(90), 0)
		a2.CFrame = a2.CFrame * CFrame.Angles(0, math.rad(90), 0)
		game:GetService("Debris"):AddItem(a, 20)
		game:GetService("Debris"):AddItem(a2, 20)
		game:GetService("Debris"):AddItem(ba, 20)
		local msh = Instance.new("SpecialMesh", a)
		msh.MeshType = "Cylinder"
		msh.Scale = vt(1, 25, 25)
		local msh2 = Instance.new("SpecialMesh", a2)
		msh2.MeshType = "Cylinder"
		msh2.Scale = vt(1, 30, 30)
		for i = 0, 10, 0.1 do
			swait()
			CameraEnshaking(1, 5)
			a2.Color = Color3.new(r / 255, g / 255, b / 255)
			orb.CFrame = root.CFrame * CFrame.new(0, 0.5, 0) + root.CFrame.lookVector * 4
			orbe.CFrame = root.CFrame * CFrame.new(0, 0.5, 0) + root.CFrame.lookVector * 4
			ray = Ray.new(orb.CFrame.p, (mouse.Hit.p - orb.CFrame.p).unit * 1000)
			hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			distance = (orb.CFrame.p - position).magnitude
			if typrot == 1 then
				rotation = rotation + 2.5
			elseif typrot == 2 then
				rotation = rotation - 2.5
			end
			RootPart.CFrame = FaceMouse()[1]
			a.Size = Vector3.new(distance, 1, 1)
			a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance / 2)
			a2.Size = Vector3.new(distance, 1, 1)
			a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance / 2)
			ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
			a.CFrame = a.CFrame * CFrame.Angles(0, math.rad(90), 0)
			a2.CFrame = a2.CFrame * CFrame.Angles(0, math.rad(90), 0)
			msh.Scale = msh.Scale - vt(0, 0.25, 0.25)
			msh2.Scale = msh2.Scale - vt(0, 0.3, 0.3)
			sphereMK(5, 1.5, "Add", ba.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 15, 15, 25, -0.15, MAINRUINCOLOR, 0)
			sphereMK(5, 1.5, "Add", ba.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 15, 15, 25, -0.15, MAINRUINCOLOR, 0)
			MagniDamage(ba, 30, 500, 60000, 0, "Normal")
		end
		a:Destroy()
		a2:Destroy()
		ba:Destroy()
		orb:Destroy()
		orbe:Destroy()
		attack = false
	end
	function UniversalSpark()
		attack = true
		local rngb = Instance.new("Part", char)
		rngb.Anchored = true
		rngb.BrickColor = origcolor
		rngb.CanCollide = false
		rngb.FormFactor = 3
		rngb.Name = "Ring"
		rngb.Material = "Neon"
		rngb.Size = Vector3.new(1, 0.05, 1)
		rngb.Transparency = 1
		rngb.TopSurface = 0
		rngb.BottomSurface = 0
		local rngmb = Instance.new("SpecialMesh", rngb)
		rngmb.MeshType = "Brick"
		rngmb.Name = "SizeMesh"
		rngmb.Scale = vt(0, 1, 0)
		local orb = rngb:Clone()
		orb.Parent = char
		orb.Transparency = 0
		orb.BrickColor = BrickColor.new("White")
		orb.Size = vt(1, 1, 1)
		local orbmish = orb.SizeMesh
		orbmish.Scale = vt(0, 0, 0)
		orbmish.MeshType = "Sphere"
		local orbe = rngb:Clone()
		orbe.Parent = char
		orbe.Transparency = 0.5
		orbe.BrickColor = BrickColor.new("New Yeller")
		orbe.Size = vt(1, 1, 1)
		local orbmish2 = orbe.SizeMesh
		orbmish2.Scale = vt(0, 0, 0)
		orbmish2.MeshType = "Sphere"
		orbe.Color = Color3.new(r / 255, g / 255, b / 255)
		rngb:Destroy()
		for i = 0, 5, 0.1 do
			swait()
			if rainbowmode == true then
				orbe.Color = Color3.new(r / 255, g / 255, b / 255)
			end
			orb.CFrame = root.CFrame * CFrame.new(0, 0.5, 0) + root.CFrame.lookVector * 11.5
			orbe.CFrame = root.CFrame * CFrame.new(0, 0.5, 0) + root.CFrame.lookVector * 11.5
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), 0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-90)), 0.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
			RH.C0 = clerp(RH.C0, cf(1, -1 - 0.05 * math.cos(sine / 25), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-0.5), math.rad(0), math.rad(0)), 0.3)
			LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.05 * math.cos(sine / 25), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-2.5), math.rad(10), math.rad(0)), 0.3)
			RootPart.CFrame = FaceMouse()[1]
		end
		orbe.Transparency = 1
		orb.Transparency = 1
		orb.CFrame = root.CFrame * CFrame.new(0, 0.5, 0) + root.CFrame.lookVector * 5
		CFuncs.Sound.Create("rbxassetid://294188875", char, 1, 1)
		CFuncs.Sound.Create("rbxassetid://741272936", char, 0.75, 1)
		CFuncs.Sound.Create("rbxassetid://1192402877", char, 1, 1)
		CFuncs.Sound.Create("rbxassetid://1208650519", char, 0.75, 1)
		CFuncs.Sound.Create("rbxassetid://164881112", char, 0.75, 1)
		CFuncs.Sound.Create("rbxassetid://429123896", char, 1, 0.85)
		CFuncs.Sound.Create("rbxassetid://164178927", char, 1, 1)
		local xd = Instance.new("Sound", char)
		xd.SoundId = "rbxassetid://445796828"
		xd.Pitch = 0.75
		xd.Looped = true
		xd.Volume = 1.25
		xd:Play()
		local a = Instance.new("Part", Character)
		a.Name = "Direction"
		a.Anchored = true
		a.BrickColor = bc("Alder")
		a.Color = MAINRUINCOLOR.Color
		a.Material = "Neon"
		a.Transparency = 0.5
		a.Shape = "Cylinder"
		a.CanCollide = false
		local a2 = Instance.new("Part", Character)
		a2.Name = "Direction"
		a2.Anchored = true
		a2.BrickColor = bc("New Yeller")
		a2.Color = MAINRUINCOLOR.Color
		a2.Material = "Neon"
		a2.Transparency = 0.5
		a2.Shape = "Cylinder"
		a2.CanCollide = false
		local ba = Instance.new("Part", Character)
		ba.Name = "HitDirect"
		ba.Anchored = true
		ba.BrickColor = bc("Really black")
		ba.Material = "Neon"
		ba.Transparency = 1
		ba.CanCollide = false
		local ray = Ray.new(orb.CFrame.p, (mouse.Hit.p - orb.CFrame.p).unit * 1000)
		local ignore = Character
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		a2.BottomSurface = 10
		a2.TopSurface = 10
		local distance = (orb.CFrame.p - position).magnitude
		a.Size = Vector3.new(distance, 1, 1)
		a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance / 2)
		a2.Size = Vector3.new(distance, 1, 1)
		a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance / 2)
		ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
		a.CFrame = a.CFrame * CFrame.Angles(0, math.rad(90), 0)
		a2.CFrame = a2.CFrame * CFrame.Angles(0, math.rad(90), 0)
		game:GetService("Debris"):AddItem(a, 60)
		game:GetService("Debris"):AddItem(a2, 60)
		game:GetService("Debris"):AddItem(ba, 60)
		local outerscale = 0
		local msh = Instance.new("SpecialMesh", a)
		msh.MeshType = "Cylinder"
		msh.Scale = vt(1, 0, 0)
		local msh2 = Instance.new("SpecialMesh", a2)
		msh2.MeshType = "Cylinder"
		msh2.Scale = vt(1, 0, 0)
		for i = 0, 2, 0.1 do
			swait()
			CameraEnshaking(1, 1)
			msh2.Scale = msh2.Scale + vt(0, outerscale * 20, outerscale * 20)
			msh.Scale = msh.Scale + vt(0, outerscale * 15, outerscale * 15)
			outerscale = outerscale - 0.015
			orb.CFrame = root.CFrame * CFrame.new(0, 0.5, 0) + root.CFrame.lookVector * 4
			orbe.CFrame = root.CFrame * CFrame.new(0, 0.5, 0) + root.CFrame.lookVector * 4
			ray = Ray.new(orb.CFrame.p, (mouse.Hit.p - orb.CFrame.p).unit * 1000)
			hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			distance = (orb.CFrame.p - position).magnitude
			if typrot == 1 then
				rotation = rotation + 2.5
			elseif typrot == 2 then
				rotation = rotation - 2.5
			end
			RootPart.CFrame = FaceMouse()[1]
			a.Size = Vector3.new(distance, 1, 1)
			a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance / 2)
			a2.Size = Vector3.new(distance, 1, 1)
			a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance / 2)
			ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
			a.CFrame = a.CFrame * CFrame.Angles(0, math.rad(90), 0)
			a2.CFrame = a2.CFrame * CFrame.Angles(0, math.rad(90), 0)
			sphereMK(5, 5, "Add", ba.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 75, 75, 225, -0.75, MAINRUINCOLOR, 0)
			sphereMK(5, 5, "Add", ba.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 75, 75, 225, -0.75, MAINRUINCOLOR, 0)
			MagniDamage(ba, 100, 500, 60000, 0, "Normal")
		end
		for z = 0, 2 do
			for i = 0, 4, 0.1 do
				swait()
				CameraEnshaking(1, 1)
				msh2.Scale = msh2.Scale + vt(0, outerscale, outerscale)
				msh.Scale = msh.Scale - vt(0, outerscale, outerscale)
				outerscale = outerscale + 0.015
				orb.CFrame = root.CFrame * CFrame.new(0, 0.5, 0) + root.CFrame.lookVector * 4
				orbe.CFrame = root.CFrame * CFrame.new(0, 0.5, 0) + root.CFrame.lookVector * 4
				ray = Ray.new(orb.CFrame.p, (mouse.Hit.p - orb.CFrame.p).unit * 1000)
				hit, position, normal = workspace:FindPartOnRay(ray, ignore)
				distance = (orb.CFrame.p - position).magnitude
				if typrot == 1 then
					rotation = rotation + 2.5
				elseif typrot == 2 then
					rotation = rotation - 2.5
				end
				RootPart.CFrame = FaceMouse()[1]
				a.Size = Vector3.new(distance, 1, 1)
				a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance / 2)
				a2.Size = Vector3.new(distance, 1, 1)
				a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance / 2)
				ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
				a.CFrame = a.CFrame * CFrame.Angles(0, math.rad(90), 0)
				a2.CFrame = a2.CFrame * CFrame.Angles(0, math.rad(90), 0)
				sphereMK(5, 5, "Add", ba.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 75, 75, 225, -0.75, MAINRUINCOLOR, 0)
				sphereMK(5, 5, "Add", ba.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 75, 75, 225, -0.75, MAINRUINCOLOR, 0)
				MagniDamage(ba, 100, 500, 60000, 0, "Normal")
			end
			for i = 0, 4, 0.1 do
				swait()
				CameraEnshaking(1, 1)
				msh2.Scale = msh2.Scale + vt(0, outerscale, outerscale)
				msh.Scale = msh.Scale - vt(0, outerscale, outerscale)
				outerscale = outerscale - 0.015
				orb.CFrame = root.CFrame * CFrame.new(0, 0.5, 0) + root.CFrame.lookVector * 4
				orbe.CFrame = root.CFrame * CFrame.new(0, 0.5, 0) + root.CFrame.lookVector * 4
				ray = Ray.new(orb.CFrame.p, (mouse.Hit.p - orb.CFrame.p).unit * 1000)
				hit, position, normal = workspace:FindPartOnRay(ray, ignore)
				distance = (orb.CFrame.p - position).magnitude
				if typrot == 1 then
					rotation = rotation + 2.5
				elseif typrot == 2 then
					rotation = rotation - 2.5
				end
				RootPart.CFrame = FaceMouse()[1]
				a.Size = Vector3.new(distance, 1, 1)
				a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance / 2)
				a2.Size = Vector3.new(distance, 1, 1)
				a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance / 2)
				ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
				a.CFrame = a.CFrame * CFrame.Angles(0, math.rad(90), 0)
				a2.CFrame = a2.CFrame * CFrame.Angles(0, math.rad(90), 0)
				sphereMK(5, 5, "Add", ba.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 75, 75, 225, -0.75, MAINRUINCOLOR, 0)
				sphereMK(5, 5, "Add", ba.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 75, 75, 225, -0.75, MAINRUINCOLOR, 0)
				MagniDamage(ba, 100, 500, 60000, 0, "Normal")
			end
		end
		for i = 0, 4, 0.1 do
			swait()
			CameraEnshaking(1, 1)
			msh2.Scale = msh2.Scale + vt(0, outerscale, outerscale)
			msh.Scale = msh.Scale - vt(0, outerscale, outerscale)
			xd.Volume = xd.Volume - 0.025
			a.Transparency = a.Transparency + 0.025
			a2.Transparency = a2.Transparency + 0.025
			outerscale = outerscale - 0.015
			orb.CFrame = root.CFrame * CFrame.new(0, 0.5, 0) + root.CFrame.lookVector * 4
			orbe.CFrame = root.CFrame * CFrame.new(0, 0.5, 0) + root.CFrame.lookVector * 4
			ray = Ray.new(orb.CFrame.p, (mouse.Hit.p - orb.CFrame.p).unit * 1000)
			hit, position, normal = workspace:FindPartOnRay(ray, ignore)
			distance = (orb.CFrame.p - position).magnitude
			if typrot == 1 then
				rotation = rotation + 2.5
			elseif typrot == 2 then
				rotation = rotation - 2.5
			end
			RootPart.CFrame = FaceMouse()[1]
			a.Size = Vector3.new(distance, 1, 1)
			a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance / 2)
			a2.Size = Vector3.new(distance, 1, 1)
			a2.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance / 2)
			ba.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
			a.CFrame = a.CFrame * CFrame.Angles(0, math.rad(90), 0)
			a2.CFrame = a2.CFrame * CFrame.Angles(0, math.rad(90), 0)
			sphereMK(5, 5, "Add", ba.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 75, 75, 225, -0.75, MAINRUINCOLOR, 0)
			sphereMK(5, 5, "Add", ba.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 75, 75, 225, -0.75, MAINRUINCOLOR, 0)
			MagniDamage(ba, 100, 500, 60000, 0, "Normal")
		end
		xd:Destroy()
		a:Destroy()
		a2:Destroy()
		ba:Destroy()
		orb:Destroy()
		orbe:Destroy()
		attack = false
	end
	function resetmode()
		rainbowmode = false
		chaosmode = false
		RecolorTextAndRename("Singularity", Color3.new(0, 0, 0), Color3.new(1, 0, 0))
		ModeOfGlitch = 1
		storehumanoidWS = 16
		for i, v in pairs(mw2:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = BrickColor.new("Really red")
				v.Material = "Neon"
			end
		end
		for i, v in pairs(mw1:GetChildren()) do
			if v:IsA("Part") then
				v.Transparency = 1
				v.BrickColor = BrickColor.new("Really red")
				v.Material = "Neon"
			end
		end
		MAINRUINCOLOR = BrickColor.new("Really red")
		hum.WalkSpeed = 16
		newTheme("rbxassetid://415898123", 0, 1, 10)
		for i, v in pairs(m:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = BrickColor.new("Really black")
				v.Material = "Glass"
			end
		end
		for i, v in pairs(m2:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = BrickColor.new("Crimson")
				v.Material = "Granite"
			end
		end
		for i, v in pairs(m3:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = BrickColor.new("Really red")
				v.Material = "Neon"
			end
		end
		for i, v in pairs(extrawingmod1:GetChildren()) do
			if v:IsA("Part") then
				v.Transparency = 1
				v.BrickColor = BrickColor.new("White")
				v.Material = "Neon"
			end
		end
		for i, v in pairs(extrawingmod2:GetChildren()) do
			if v:IsA("Part") then
				v.Transparency = 1
				v.BrickColor = BrickColor.new("White")
				v.Material = "Neon"
			end
		end
	end
	function attackone()
		attack = true
		for i = 0, 1, 0.1 do
			swait()
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * angles(math.rad(20), math.rad(0), math.rad(-40)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(40)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-40)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-40)), 0.2)
			RH.C0 = clerp(RH.C0, cf(1, -1 - 0.05 * math.cos(sine / 25), -0.75) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(20)), 0.2)
			LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.05 * math.cos(sine / 25), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(10)), 0.2)
		end
		CFuncs.Sound.Create("rbxassetid://200632136", root, 1, 1.1)
		local hitb = Instance.new("Part", char)
		hitb.Anchored = true
		hitb.CanCollide = false
		hitb.FormFactor = 3
		hitb.Name = "Ring"
		hitb.Material = "Neon"
		hitb.Size = Vector3.new(1, 1, 1)
		hitb.Transparency = 1
		hitb.TopSurface = 0
		hitb.BottomSurface = 0
		hitb.CFrame = root.CFrame + root.CFrame.lookVector * 2
		MagniDamage(hitb, 3, 10, 30, 0, "Normal")
		hitb:Destroy()
		for i = 0, 1, 0.1 do
			swait()
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * angles(math.rad(-5), math.rad(0), math.rad(70)), 0.4)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(20), math.rad(0), math.rad(-70)), 0.4)
			RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(70)), 0.4)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(40)), 0.4)
			RH.C0 = clerp(RH.C0, cf(1, -1 - 0.05 * math.cos(sine / 25), -0.75) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(-40)), 0.4)
			LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.05 * math.cos(sine / 25), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(-10)), 0.4)
		end
		attack = false
	end
	function attacktwo()
		attack = true
		for i = 0, 1, 0.1 do
			swait()
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * angles(math.rad(20), math.rad(0), math.rad(40)), 0.2)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(40)), 0.2)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(40)), 0.2)
			RH.C0 = clerp(RH.C0, cf(1, -1 - 0.05 * math.cos(sine / 25), -0.75) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(20)), 0.2)
			LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.05 * math.cos(sine / 25), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(10)), 0.2)
		end
		CFuncs.Sound.Create("rbxassetid://200632136", root, 1, 1)
		local hitb = Instance.new("Part", char)
		hitb.Anchored = true
		hitb.CanCollide = false
		hitb.FormFactor = 3
		hitb.Name = "Ring"
		hitb.Material = "Neon"
		hitb.Size = Vector3.new(1, 1, 1)
		hitb.Transparency = 1
		hitb.TopSurface = 0
		hitb.BottomSurface = 0
		hitb.CFrame = root.CFrame + root.CFrame.lookVector * 2
		MagniDamage(hitb, 3, 10, 30, 0, "Normal")
		hitb:Destroy()
		for i = 0, 1, 0.1 do
			swait()
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * angles(math.rad(-5), math.rad(0), math.rad(-70)), 0.4)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(20), math.rad(0), math.rad(70)), 0.4)
			RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-40)), 0.4)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-70)), 0.4)
			RH.C0 = clerp(RH.C0, cf(1, -1 - 0.05 * math.cos(sine / 25), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(-40)), 0.4)
			LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.05 * math.cos(sine / 25), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(-10)), 0.4)
		end
		attack = false
	end
	function attackthree()
		attack = true
		for i = 0, 1, 0.1 do
			swait()
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(80)), 0.3)
			Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(20), math.rad(0), math.rad(-80)), 0.3)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(80)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20)), 0.3)
			RH.C0 = clerp(RH.C0, cf(1, -1 - 0.05 * math.cos(sine / 25), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-0.5), math.rad(0), math.rad(0)), 0.3)
			LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.05 * math.cos(sine / 25), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-2.5), math.rad(10), math.rad(0)), 0.3)
		end
		local distlook = 5
		for i = 0, 4 do
			swait(2)
			CameraEnshaking(2, 3)
			local hite = Instance.new("Part", char)
			hite.Anchored = true
			hite.CanCollide = false
			hite.FormFactor = 3
			hite.Name = "Ring"
			hite.Material = "Neon"
			hite.Size = Vector3.new(1, 1, 1)
			hite.Transparency = 1
			hite.TopSurface = 0
			hite.BottomSurface = 0
			hite.CFrame = root.CFrame + root.CFrame.lookVector * distlook
			sphere(3, "Add", hite.CFrame, vt(0, 0, 0), 0.15, MAINRUINCOLOR)
			sphere(6, "Add", hite.CFrame, vt(0, 0, 0), 0.3, MAINRUINCOLOR)
			MagniDamage(hite, 10, 15, 35, 0, "Normal")
			for i = 0, 2 do
				sphereMK(2, 0.2, "Add", rarm.CFrame * CFrame.Angles(math.rad(-90 + math.random(-20, 20)), math.rad(math.random(-20, 20)), math.rad(math.random(-20, 20))), 0.5, 0.5, 5, -0.005, MAINRUINCOLOR, 0)
				sphereMK(3, 0.2, "Add", hite.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 0.5, 0.5, 5, -0.005, MAINRUINCOLOR, 0)
				sphereMK(6, 0.35, "Add", hite.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 0.5, 0.5, 5, -0.005, MAINRUINCOLOR, 0)
			end
			CFuncs.Sound.Create("rbxassetid://183763506", hite, 2.5, 1)
			CFuncs.Sound.Create("rbxassetid://178452221", hite, 0.25, 0.6)
			game:GetService("Debris"):AddItem(hite, 5)
			distlook = distlook + 10
		end
		attack = false
	end
	local attacktype = 1
	mouse.Button1Down:connect(function()
		if attack == false and attacktype == 1 then
			attacktype = 2
			attackone()
		elseif attack == false and attacktype == 2 then
			attacktype = 3
			attacktwo()
		elseif attack == false and attacktype == 3 then
			attacktype = 1
			attackthree()
		elseif attack == false and attacktype == 4 then
			attacktype = 1
		end
	end)
	mouse.KeyDown:connect(function(k)
		if k == "q" and attack == false and ModeOfGlitch ~= 2 then
			ModeOfGlitch = 2
			storehumanoidWS = 16
			hum.WalkSpeed = 16
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("Purity", Color3.new(1, 1, 1), Color3.new(0, 1, 1))
			newTheme("rbxassetid://1119453744", 20.25, 1, 1)
			MAINRUINCOLOR = BrickColor.new("Toothpaste")
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("White")
					v.Material = "Ice"
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Pastel light blue")
					v.Material = "Glass"
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Toothpaste")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod2:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
		elseif k == "q" and attack == false and ModeOfGlitch == 2 then
			resetmode()
		end
		if k == "e" and attack == false and ModeOfGlitch ~= 3 then
			ModeOfGlitch = 3
			storehumanoidWS = 16
			hum.WalkSpeed = 16
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("Corruption", Color3.new(0, 0, 0), Color3.new(0.35, 0, 1))
			newTheme("rbxassetid://1509634377", 58.15, 1,2)
			MAINRUINCOLOR = BrickColor.new("Royal purple")
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Black")
					v.Material = "Ice"
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Dark indigo")
					v.Material = "Glass"
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Royal purple")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod2:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
		elseif k == "e" and attack == false and ModeOfGlitch == 3 then
			resetmode()
		end
		if k == "r" and attack == false and ModeOfGlitch ~= 4 then
			ModeOfGlitch = 4
			storehumanoidWS = 16
			hum.WalkSpeed = 16
			rainbowmode = false
			chaosmode = true
			RecolorTextAndRename("HATRED", Color3.new(0, 0, 0), BrickColor.random().Color)
			newTheme("rbxassetid://415898123", 0, 1, 10)
			MAINRUINCOLOR = BrickColor.new("Black")
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0.75
					v.BrickColor = BrickColor.random()
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Black")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.random()
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Black")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod2:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
		elseif k == "r" and attack == false and ModeOfGlitch == 4 then
			resetmode()
		end
		if k == "t" and attack == false and ModeOfGlitch ~= 5 then
			ModeOfGlitch = 5

			storehumanoidWS = 16
			hum.WalkSpeed = 16
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("Solitude", Color3.new(0, 0, 0), Color3.new(255, 255, 255))
			newTheme("rbxassetid://723652641", 10, 1, 3.2)
			ModeOfGlitch = 1		
			MAINRUINCOLOR = BrickColor.new("Really black")
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Really black")
					v.Material = "Ice"
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Really black")
					v.Material = "Ice"
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Really black")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod2:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
		elseif k == "t" and attack == false and ModeOfGlitch == 5 then
			resetmode()
		end
		if k == "y" and attack == false and ModeOfGlitch ~= 6 then
			ModeOfGlitch = 6
			storehumanoidWS = 75
			hum.WalkSpeed = 75
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("Equality", Color3.new(0, 0, 0), Color3.new(1, 1, 1))
			newTheme("rbxassetid://519067542", 0, 1, 1)
			MAINRUINCOLOR = BrickColor.new("Really black")
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0
					v.BrickColor = BrickColor.new("Really black")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("White")
					v.Material = "Ice"
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("Really black")
					v.Material = "Ice"
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod2:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end


		elseif k == "y" and attack == false and ModeOfGlitch == 6 then
			resetmode()
		end
		if k == "u" and attack == false and ModeOfGlitch ~= 6127843 then
			ModeOfGlitch = 6127843
			storehumanoidWS = 50
			hum.WalkSpeed = 50
			rainbowmode = true
			chaosmode = false
			RecolorTextAndRename("StarLight", Color3.new(1, 1, 1), Color3.new(1, 1, 1))
			newTheme("rbxassetid://152539141", 0, 1, 1)
			MAINRUINCOLOR = BrickColor.new("White")
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod2:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 1
					v.BrickColor = BrickColor.new("White")
					v.Material = "Neon"
				end
			end
		elseif k == "u" and attack == false and ModeOfGlitch == 6127843 then
			resetmode()
		end
		if k == "p" and attack == false and ModeOfGlitch ~= 1000000 then
			ModeOfGlitch = 1000000
			storehumanoidWS = 100
			hum.WalkSpeed = 100
			rainbowmode = false
			chaosmode = false
			RecolorTextAndRename("True Starlight", Color3.new(0.25, 0, 1), Color3.new(0.5, 0, 1))
			newTheme("rbxassetid://614032233", 0, 1, 1)
			MAINRUINCOLOR = BrickColor.new("Bright violet")
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0
					v.BrickColor = MAINRUINCOLOR
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(0.5, 0, 1)
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(0.25, 0, 1)
					v.Material = "Neon"
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(0.45, 0, 1)
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod1:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0
					v.Color = Color3.new(0.25, 0, 1)
					v.Material = "Neon"
				end
			end
			for i, v in pairs(extrawingmod2:GetChildren()) do
				if v:IsA("Part") then
					v.Transparency = 0
					v.Color = Color3.new(0.5, 0, 1)
					v.Material = "Neon"
				end
			end
		elseif k == "p" and attack == false and ModeOfGlitch == 1000000 then
			resetmode()
		end
		if k == "l" and toggleTag == false then
			toggleTag = true
			text.TextTransparency = 0
			text.TextStrokeTransparency = 0
		elseif k == "l" and toggleTag == true then
			toggleTag = false
			text.TextTransparency = 1
			text.TextStrokeTransparency = 1
		end
		if k == "z" and attack == false and ModeOfGlitch == 1 then
			ExtinctiveHeartbreak()
		elseif k == "z" and attack == false and ModeOfGlitch == 2 then
			PureBomb()
		elseif k == "z" and attack == false and ModeOfGlitch == 3 then
			scattercorrupt()
		elseif k == "z" and attack == false and ModeOfGlitch == 4 then
			ChaosGroundStrike()
		elseif k == "z" and attack == false and ModeOfGlitch == 5 then
		elseif k == "z" and attack == false and ModeOfGlitch == 1000000 then
			UniversalSpark()
		elseif k == "l" and attack == false and ModeOfGlitch == 1000000 then
			scattercorrupt()
			wait(1)
			yinyangi()
		elseif k == "l" and attack == false and ModeOfGlitch == 5 then
			scattercorrupt()
			scattercorrupt()
		elseif k == "z" and attack == false and ModeOfGlitch == 6 then
			yinyangi()
		elseif k == "z" and attack == false and ModeOfGlitch == 6127843 then
			Wip()
		end
		if k == "l" and attack == false and ModeOfGlitch == 4 then
			ChaosBegone()
		end
	end)
	coroutine.resume(coroutine.create(function()
		while true do
			swait(2)
			if rainbowmode == true or ModeOfGlitch == 6 then
				sphereMK(5, 0.15, "Add", root.CFrame * CFrame.new(math.random(-5, 5), -6, math.random(-5, 5)) * CFrame.Angles(math.rad(90), 0, 0), 1.5, 1.5, 10, -0.015, MAINRUINCOLOR, 0)
			end
		end
	end))
	coroutine.resume(coroutine.create(function()
		while true do
			swait(0.5)
			if ModeOfGlitch == 1000000 then
				sphereMK(5, 0.5, "Add", root.CFrame * CFrame.new(math.random(-25, 25), -10, math.random(-25, 25)) * CFrame.Angles(math.rad(90 + math.random(-15, 15)), math.rad(math.random(-15, 15)), 0), 1, 1, 15, -0.01, MAINRUINCOLOR, 0)
			end
		end
	end))
	coroutine.resume(coroutine.create(function()
		while true do
			swait(2)
			if chaosmode == true then
				RecolorTextAndRename("HATRED", Color3.new(0, 0, 0), BrickColor.random().Color)
				for i, v in pairs(mw1:GetChildren()) do
					if v:IsA("Part") then
						v.Transparency = 0.75
						v.BrickColor = BrickColor.random()
						v.Material = "Neon"
					end
				end
				for i, v in pairs(m2:GetChildren()) do
					if v:IsA("Part") then
						v.BrickColor = BrickColor.random()
						v.Material = "Neon"
					end
				end
			end
		end
	end))
	Humanoid.Name = "STARGLITCHER"
	Humanoid.MaxHealth = math.huge
	Humanoid.Health = math.huge
	Instance.new("ForceField", char).Visible = false
	Humanoid.Animator.Parent = nil
	idleanim = 0.4
	while true do
		if rainbowmode == true then
			RecolorTextAndRename("StarLight", Color3.new(r / 255, g / 255, b / 255), Color3.new(r / 500, g / 500, b / 500))
			MAINRUINCOLOR = BrickColor.new("White")
			for i, v in pairs(m:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(r / 255, g / 255, b / 255)
				end
			end
			for i, v in pairs(m2:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(r / 255, g / 255, b / 255)
				end
			end
			for i, v in pairs(m3:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(r / 255, g / 255, b / 255)
				end
			end
			for i, v in pairs(mw1:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(r / 255, g / 255, b / 255)
					v.Material = "Neon"
				end
			end
			for i, v in pairs(mw2:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(r / 255, g / 255, b / 255)
					v.Material = "Neon"
				end
			end
		end
		CameraManager()
		swait()
		lwing1weld.C1 = clerp(lwing1weld.C1, cf(2, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)) * angles(math.rad(5 + 10 * math.cos(sine / 32)), math.rad(0), math.rad(12.5 + 5 * math.cos(sine / 32))), 0.3)
		lwing2weld.C1 = clerp(lwing2weld.C1, cf(3, 1, 0) * angles(math.rad(0), math.rad(0), math.rad(0)) * angles(math.rad(10 + 15 * math.cos(sine / 32)), math.rad(0), math.rad(25 + 7.5 * math.cos(sine / 32))), 0.3)
		lwing3weld.C1 = clerp(lwing3weld.C1, cf(3.75, 2, 0) * angles(math.rad(0), math.rad(0), math.rad(0)) * angles(math.rad(15 + 20 * math.cos(sine / 32)), math.rad(0), math.rad(37.5 + 10 * math.cos(sine / 32))), 0.3)
		lwing4weld.C1 = clerp(lwing4weld.C1, cf(4.75, 3, 0) * angles(math.rad(0), math.rad(0), math.rad(0)) * angles(math.rad(20 + 25 * math.cos(sine / 32)), math.rad(0), math.rad(50 + 12.5 * math.cos(sine / 32))), 0.3)
		lwing5weld.C1 = clerp(lwing5weld.C1, cf(5.75, 4, 0) * angles(math.rad(0), math.rad(0), math.rad(0)) * angles(math.rad(25 + 30 * math.cos(sine / 32)), math.rad(0), math.rad(62.5 + 15 * math.cos(sine / 32))), 0.3)
		lwing6weld.C1 = clerp(lwing6weld.C1, cf(6.75, 5, 0) * angles(math.rad(0), math.rad(0), math.rad(0)) * angles(math.rad(30 + 35 * math.cos(sine / 32)), math.rad(0), math.rad(75 + 17.5 * math.cos(sine / 32))), 0.3)
		rwing1weld.C1 = clerp(rwing1weld.C1, cf(-2, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)) * angles(math.rad(5 + 10 * math.cos(sine / 32)), math.rad(0), math.rad(-12.5 - 5 * math.cos(sine / 32))), 0.3)
		rwing2weld.C1 = clerp(rwing2weld.C1, cf(-3, 1, 0) * angles(math.rad(0), math.rad(0), math.rad(0)) * angles(math.rad(10 + 15 * math.cos(sine / 32)), math.rad(0), math.rad(-25 - 7.5 * math.cos(sine / 32))), 0.3)
		rwing3weld.C1 = clerp(rwing3weld.C1, cf(-3.75, 2, 0) * angles(math.rad(0), math.rad(0), math.rad(0)) * angles(math.rad(15 + 20 * math.cos(sine / 32)), math.rad(0), math.rad(-37.5 - 10 * math.cos(sine / 32))), 0.3)
		rwing4weld.C1 = clerp(rwing4weld.C1, cf(-4.75, 3, 0) * angles(math.rad(0), math.rad(0), math.rad(0)) * angles(math.rad(20 + 25 * math.cos(sine / 32)), math.rad(0), math.rad(-50 - 12.5 * math.cos(sine / 32))), 0.3)
		rwing5weld.C1 = clerp(rwing5weld.C1, cf(-5.75, 4, 0) * angles(math.rad(0), math.rad(0), math.rad(0)) * angles(math.rad(25 + 30 * math.cos(sine / 32)), math.rad(0), math.rad(-62.5 - 15 * math.cos(sine / 32))), 0.3)
		rwing6weld.C1 = clerp(rwing6weld.C1, cf(-6.75, 5, 0) * angles(math.rad(0), math.rad(0), math.rad(0)) * angles(math.rad(30 + 35 * math.cos(sine / 32)), math.rad(0), math.rad(-75 - 17.5 * math.cos(sine / 32))), 0.3)
		sine = sine + change
		local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
		local velderp = RootPart.Velocity.y
		hitfloor, posfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
		if equipped == true or equipped == false then
			if attack == false then
				idle = idle + 1
			else
				idle = 0
			end
			if not (idle >= 500) or attack == false then
			end
			if RootPart.Velocity.y > 1 and hitfloor == nil then
				Anim = "Jump"
				if attack == false then
					RH.C0 = clerp(RH.C0, cf(1, -1 - 0.05 * math.cos(sine / 25), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(-20)), 0.1)
					LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.05 * math.cos(sine / 25), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(20)), 0.1)
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0 + 0.05 * math.cos(sine / 25)) * angles(math.rad(-10), math.rad(0), math.rad(0)), 0.1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-2.5), math.rad(0), math.rad(0)), 0.1)
					RW.C0 = clerp(RW.C0, cf(1.45, 0.5 + 0.1 * math.cos(sine / 25), 0) * angles(math.rad(-5), math.rad(0), math.rad(25)), 0.1)
					LW.C0 = clerp(LW.C0, cf(-1.45, 0.5 + 0.1 * math.cos(sine / 25), 0) * angles(math.rad(-5), math.rad(0), math.rad(-25)), 0.1)
				end
			elseif RootPart.Velocity.y < -1 and hitfloor == nil then
				Anim = "Fall"
				if attack == false then
					RH.C0 = clerp(RH.C0, cf(1, -1 - 0.05 * math.cos(sine / 25), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(-20)), 0.1)
					LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.05 * math.cos(sine / 25), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-5), math.rad(0), math.rad(20)), 0.1)
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0 + 0.05 * math.cos(sine / 25)) * angles(math.rad(0), math.rad(0), math.rad(0)), 0.1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(0)), 0.1)
					RW.C0 = clerp(RW.C0, cf(1.45, 0.5 + 0.1 * math.cos(sine / 25), 0) * angles(math.rad(-20), math.rad(0), math.rad(50)), 0.1)
					LW.C0 = clerp(LW.C0, cf(-1.45, 0.5 + 0.1 * math.cos(sine / 25), 0) * angles(math.rad(-20), math.rad(0), math.rad(-50)), 0.1)
				end
			elseif torvel < 1 and hitfloor ~= nil then
				Anim = "Idle"
				if attack == false then
					if ModeOfGlitch == 1 then
						RH.C0 = clerp(RH.C0, cf(1, -1 - 0.1 * math.cos(sine / 32), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-10 - 2.5 * math.cos(sine / 32)), math.rad(-20), math.rad(0)), 0.1)
						LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.1 * math.cos(sine / 32), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(-10 + 2.5 * math.cos(sine / 32))), 0.1)
						RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0 + 0.1 * math.cos(sine / 32)) * angles(math.rad(10 - 2 * math.cos(sine / 32)), math.rad(0), math.rad(20)), 0.1)
						Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(25 - 2.5 * math.cos(sine / 32)), math.rad(0 - 5 * math.cos(sine / 0.25)), math.rad(-20 - 5 * math.cos(sine / 0.465))), 0.1)
						RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(10), math.rad(-20), math.rad(30 + 2.5 * math.cos(sine / 25))), 0.1)
						LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(160), math.rad(0), math.rad(25)), 0.1)
					elseif ModeOfGlitch == 2 or ModeOfGlitch == 6127843 then
						RH.C0 = clerp(RH.C0, cf(1, -1 - 0.05 * math.cos(sine / 28), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-7.5), math.rad(0), math.rad(0 + 1 * math.cos(sine / 34))), 0.1)
						LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.05 * math.cos(sine / 28), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(0 + 1 * math.cos(sine / 34))), 0.1)
						RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0 + 0.05 * math.cos(sine / 28)) * angles(math.rad(0 - 1 * math.cos(sine / 34)), math.rad(0), math.rad(0)), 0.1)
						Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(15 - 2.5 * math.cos(sine / 28)), math.rad(0), math.rad(0)), 0.1)
						RW.C0 = clerp(RW.C0, cf(0.85, 0.5 + 0.1 * math.cos(sine / 28), -0.65) * angles(math.rad(30 - 1 * math.cos(sine / 34)), math.rad(0), math.rad(-100 - 2.5 * math.cos(sine / 28))), 0.1)
						LW.C0 = clerp(LW.C0, cf(-0.85, 0.5 + 0.1 * math.cos(sine / 28), -0.65) * angles(math.rad(40 - 1 * math.cos(sine / 34)), math.rad(0), math.rad(90 + 2.5 * math.cos(sine / 28))), 0.1)
					elseif ModeOfGlitch == 3 then
						RH.C0 = clerp(RH.C0, cf(1, -1 - 0.05 * math.cos(sine / 28), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(0 - 1 * math.cos(sine / 34))), 0.1)
						LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.05 * math.cos(sine / 28), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(0 + 1 * math.cos(sine / 34))), 0.1)
						RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0 + 0.05 * math.cos(sine / 28)) * angles(math.rad(0 - 1 * math.cos(sine / 34)), math.rad(0), math.rad(-20)), 0.1)
						Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(25 - 2.5 * math.cos(sine / 28)), math.rad(0), math.rad(20)), 0.1)
						RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(10), math.rad(-20), math.rad(30 + 2.5 * math.cos(sine / 25))), 0.1)
						LW.C0 = clerp(LW.C0, cf(-1.5, 0.75, 0) * angles(math.rad(170), math.rad(-20), math.rad(20)), 0.1)
					elseif ModeOfGlitch == 4 then
						RH.C0 = clerp(RH.C0, cf(1, -1 - 0.025 * math.cos(sine / 32), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-1.5), math.rad(0), math.rad(20)), 0.1)
						LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.025 * math.cos(sine / 32), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-1.5), math.rad(0), math.rad(-20)), 0.1)
						RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0 + 0.025 * math.cos(sine / 32)) * angles(math.rad(20 - 0.5 * math.cos(sine / 32)), math.rad(0), math.rad(0)), 0.1)
						Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(30 - 5 * math.cos(sine / 0.5265)), math.rad(0 - 5 * math.cos(sine / 0.25)), math.rad(0 - 5 * math.cos(sine / 0.465))), 0.1)
						RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(10 + 2.5 * math.cos(sine / 0.252)), math.rad(0 + 2.5 * math.cos(sine / 0.123)), math.rad(5 + 2.5 * math.cos(sine / 0.6))), 0.1)
						LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(10 + 2.5 * math.cos(sine / 0.568)), math.rad(0 + 2.5 * math.cos(sine / 0.664)), math.rad(-5 + 2.5 * math.cos(sine / 0.23))), 0.1)
					elseif ModeOfGlitch == 5 then
						RH.C0 = clerp(RH.C0, cf(1, -1 - 0.05 * math.cos(sine / 28), 0) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(0 + 1 * math.cos(sine / 34))), 0.1)
						LH.C0 = clerp(LH.C0, cf(-1, -1 - 0.05 * math.cos(sine / 28), 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(0 + 1 * math.cos(sine / 34))), 0.1)
						RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0 + 0.05 * math.cos(sine / 28)) * angles(math.rad(0 - 1 * math.cos(sine / 34)), math.rad(0), math.rad(0)), 0.1)
						Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(5 - 2.5 * math.cos(sine / 28)), math.rad(0), math.rad(0)), 0.1)
						RW.C0 = clerp(RW.C0, cf(1, 0.5 + 0.1 * math.cos(sine / 28), 0.45) * angles(math.rad(-30), math.rad(0), math.rad(-30)), 0.1)
						LW.C0 = clerp(LW.C0, cf(-1, 0.5 + 0.1 * math.cos(sine / 28), 0.45) * angles(math.rad(-30), math.rad(0), math.rad(30)), 0.1)
					elseif ModeOfGlitch == 6 or ModeOfGlitch == 1000000 then
						RH.C0 = clerp(RH.C0, cf(1, -0.25, -0.5) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(-10)), 0.1)
						LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(10)), 0.1)
						RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 1.5 + 0.1 * math.cos(sine / 28)) * angles(math.rad(0 - 1 * math.cos(sine / 34)), math.rad(0), math.rad(0)), 0.1)
						Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(15), math.rad(0), math.rad(0)), 0.1)
						RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(20 + 2.5 * math.cos(sine / 28))), 0.1)
						LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-20 - 2.5 * math.cos(sine / 28))), 0.1)
					end
				end
			elseif torvel > 2 and torvel < 22 and hitfloor ~= nil then
				Anim = "Walk"
				if attack == false then
					if ModeOfGlitch == 1 then
						RH.C0 = clerp(RH.C0, cf(1, -0.85, -0.15 - 0.15 * math.cos(sine / 4)) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(0), math.rad(0 + 5 * math.cos(sine / 8)), math.rad(0 + 25 * math.cos(sine / 8))), 0.1)
						LH.C0 = clerp(LH.C0, cf(-1, -0.85, -0.15 + 0.15 * math.cos(sine / 4)) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(0), math.rad(0 + 5 * math.cos(sine / 8)), math.rad(0 + 25 * math.cos(sine / 8))), 0.1)
						RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.15 - 0.1 * math.cos(sine / 4)) * angles(math.rad(5), math.rad(0), math.rad(0 - 5 * math.cos(sine / 8))), 0.1)
						Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(25 - 5 * math.cos(sine / 0.325)), math.rad(0 - 5 * math.cos(sine / 0.25)), math.rad(0 + 5 * math.cos(sine / 8))), 0.1)
						RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(0 - 45 * math.cos(sine / 8)), math.rad(0), math.rad(10 - 10 * math.cos(sine / 4))), 0.1)
						LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(160), math.rad(0), math.rad(25)), 0.1)
					elseif ModeOfGlitch == 4 then
						RH.C0 = clerp(RH.C0, cf(1, -0.85, -0.15 - 0.15 * math.cos(sine / 8)) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(0), math.rad(0 + 5 * math.cos(sine / 12)), math.rad(5 + 25 * math.cos(sine / 12))), 0.1)
						LH.C0 = clerp(LH.C0, cf(-1, -0.85, -0.15 + 0.15 * math.cos(sine / 8)) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(0), math.rad(0 + 5 * math.cos(sine / 12)), math.rad(-5 + 25 * math.cos(sine / 12))), 0.1)
						RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.15 - 0.1 * math.cos(sine / 8)) * angles(math.rad(12.5), math.rad(0), math.rad(0 - 5 * math.cos(sine / 12))), 0.1)
						Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(30 - 5 * math.cos(sine / 0.5265)), math.rad(0 - 5 * math.cos(sine / 0.25)), math.rad(0 - 5 * math.cos(sine / 0.465))), 0.1)
						RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(10 - 15 * math.cos(sine / 12)), math.rad(0 + 2.5 * math.cos(sine / 0.123)), math.rad(5 + 2.5 * math.cos(sine / 0.6))), 0.1)
						LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(10 + 15 * math.cos(sine / 12)), math.rad(0 + 2.5 * math.cos(sine / 0.664)), math.rad(-5 + 2.5 * math.cos(sine / 0.23))), 0.1)
					elseif ModeOfGlitch ~= 1 or ModeOfGlitch ~= 4 then
						RH.C0 = clerp(RH.C0, cf(1, -0.85, -0.15 - 0.15 * math.cos(sine / 4)) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(0), math.rad(0 + 5 * math.cos(sine / 8)), math.rad(0 + 25 * math.cos(sine / 8))), 0.1)
						LH.C0 = clerp(LH.C0, cf(-1, -0.85, -0.15 + 0.15 * math.cos(sine / 4)) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(0), math.rad(0 + 5 * math.cos(sine / 8)), math.rad(0 + 25 * math.cos(sine / 8))), 0.1)
						RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.15 - 0.1 * math.cos(sine / 4)) * angles(math.rad(5), math.rad(0), math.rad(0 - 5 * math.cos(sine / 8))), 0.1)
						Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(10 + 2.5 * math.cos(sine / 100)), math.rad(0), math.rad(0 + 5 * math.cos(sine / 8))), 0.1)
						RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(0 - 45 * math.cos(sine / 8)), math.rad(0), math.rad(10 - 10 * math.cos(sine / 4))), 0.1)
						LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(0 + 45 * math.cos(sine / 8)), math.rad(0), math.rad(-10 + 10 * math.cos(sine / 4))), 0.1)
					end
				end
			elseif torvel >= 22 and hitfloor ~= nil then
				Anim = "Run"
				if attack == false then
					if ModeOfGlitch ~= 6 and ModeOfGlitch ~= 1000000 then
						RH.C0 = clerp(RH.C0, cf(1, -0.75 - 0.25 * math.cos(sine / 3), -0.25 - 0.25 * math.cos(sine / 3)) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(0 + 95 * math.cos(sine / 6))), 0.1)
						LH.C0 = clerp(LH.C0, cf(-1, -0.75 + 0.25 * math.cos(sine / 3), -0.25 + 0.25 * math.cos(sine / 3)) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(0 + 95 * math.cos(sine / 6))), 0.1)
						RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.125 + 0.125 * math.cos(sine / 3)) * angles(math.rad(20), math.rad(0), math.rad(0 - 15 * math.cos(sine / 6))), 0.1)
						Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-10 + 2.5 * math.cos(sine / 100)), math.rad(0), math.rad(0 + 15 * math.cos(sine / 6))), 0.1)
						RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(0 - 155 * math.cos(sine / 6)), math.rad(0), math.rad(5 - 10 * math.cos(sine / 3))), 0.1)
						LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(0 + 155 * math.cos(sine / 6)), math.rad(0), math.rad(-5 + 10 * math.cos(sine / 3))), 0.1)
					elseif ModeOfGlitch == 6 or ModeOfGlitch == 1000000 then
						RH.C0 = clerp(RH.C0, cf(1, -0.25, -0.5) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(-20)), 0.2)
						LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(-2.5), math.rad(0), math.rad(20)), 0.2)
						RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, -0.5, 0.5 + 0.1 * math.cos(sine / 28)) * angles(math.rad(75), math.rad(0), math.rad(0)), 0.2)
						Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-20), math.rad(0), math.rad(0)), 0.2)
						RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(-30), math.rad(0), math.rad(30 + 2.5 * math.cos(sine / 28))), 0.2)
						LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(-30), math.rad(0), math.rad(-30 - 2.5 * math.cos(sine / 28))), 0.2)
					end
				end
			end
		end
	end
end)()

local Connection
Connection = game.Workspace.DescendantAdded:Connect(function(c)
	if c.Name == "Animate" and c.Parent == Player.Character then
		c.Enabled = false   
		Connection:Disconnect()
	end
end)
repeat task.wait() until game.Players.LocalPlayer.Character
task.wait(0.1)
local RealChar = Player.Character
RealChar.Archivable = true
FakeCharacter.Name = Player.Name .. "_Fake"
FakeCharacter.Parent = workspace
task.spawn(function()
	for i, LS in ipairs(FakeCharacter:GetChildren()) do
		if LS:IsA("LocalScript") then
			LS.Enabled = false
			task.wait(0.1)
			LS.Enabled = false
		end
	end
end)

for i, Part in ipairs(FakeCharacter:GetDescendants()) do
	if Part:IsA("BasePart")then

	end
end

for i, Decal in ipairs(FakeCharacter:GetDescendants()) do
	if Decal:IsA("Decal")then

	end
end

Player.Character = FakeCharacter


local function MotorAngle()
	if RealChar:FindFirstChild("Torso") then
		for MotorName, Motor6DAngle in pairs(Motors) do
			if RealChar:FindFirstChild("Torso"):FindFirstChild(MotorName) then
				RealChar:FindFirstChild("Torso"):FindFirstChild(MotorName).CurrentAngle = Motor6DAngle
			end
		end
	end
end

local function SetAngles()
	if FakeCharacter:FindFirstChild("Torso") then
		for MotorName, Motor6DAngle in pairs(Motors) do
			if FakeCharacter:FindFirstChild("Torso"):FindFirstChild(MotorName) then
				local Motor = FakeCharacter:FindFirstChild("Torso"):FindFirstChild(MotorName) 
				local rx, ry, rz = Motor.Part1.CFrame:ToObjectSpace(FakeCharacter:FindFirstChild("Torso").CFrame):ToOrientation()
				--Motors[MotorName] = rx
				if Motor.Name == "Right Shoulder" then
					Motors[MotorName] = -rx
				end
				if Motor.Name == "Left Shoulder" then
					Motors[MotorName] = rx
				end
				if Motor.Name == "Right Hip" then
					Motors[MotorName] = -rx
				end
				if Motor.Name == "Left Hip" then
					Motors[MotorName] = rx
				end
				if Motor.Name == "Neck" then
					Motors[MotorName] = -ry
				end
			end
		end
	end
end

local KFFolder = Instance.new("Folder")
KFFolder.Parent = game.ReplicatedStorage

local function BaseCol()
	for i, Part in ipairs(RealChar:GetChildren()) do
		if Part:IsA("BasePart")then
			Part.CanCollide = false
		end
	end
	for i, Part in ipairs(FakeCharacter:GetChildren()) do
		if Part:IsA("BasePart")then
			Part.CanCollide = false
		end
	end
end

RunService.Heartbeat:Connect(function()
	SetAngles()
	MotorAngle()
	RealChar.HumanoidRootPart.CFrame = FakeCharacter.Torso.CFrame

end)

RunService.PreSimulation:Connect(function()
	BaseCol()
end)
